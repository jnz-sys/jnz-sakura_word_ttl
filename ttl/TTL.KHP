//2015.12.20
//TTL用キーワードヘルプファイル

●システム変数
groupmatchstr /// システム変数
groupmatchstr1 /// システム変数
groupmatchstr2 /// システム変数
groupmatchstr3 /// システム変数
groupmatchstr4 /// システム変数
groupmatchstr5 /// システム変数
groupmatchstr6 /// システム変数
groupmatchstr7 /// システム変数
groupmatchstr8 /// システム変数
groupmatchstr9 /// システム変数
inputstr /// システム変数
matchstr /// システム変数
param /// システム変数
param1 /// システム変数
param2 /// システム変数
param3 /// システム変数
param4 /// システム変数
param5 /// システム変数
param6 /// システム変数
param7 /// システム変数
param8 /// システム変数
param9 /// システム変数
paramcnt /// システム変数
result /// システム変数
timeout /// システム変数
mtimeout /// システム変数

●通信コマンド
bplusrecv /// 【コマンド】\nbplusrecv\n\n【概要】\nB-Plus プロトコルでファイルを受信する。\n\n【書式】\nbplusrecv\n\n【解説】\nB-Plus プロトコルでファイルを受信する。 受信が終わるまで次のコマンドは実行されない。 ファイルが正しく転送された場合、システム変数 result に 1 が格納される。それ以外の場合, result に 0 が格納される。\n\n
bplussend /// 【コマンド】\nbplussend\n\n【概要】\nB-Plus プロトコルでファイルを送信する。\n\n【書式】\nbplussend <filename>\n\n【解説】\nファイル <filename> を B-Plus プロトコルで送信する。 送信が終わるまで次のコマンドは実行されない。 ファイルが正しく転送された場合、システム変数 result に 1 が格納される。それ以外の場合、 result に 0 が格納される。\n\n
callmenu /// 【コマンド】\ncallmenu\n\n【概要】\nウインドウのメニューを実行する。\n\n【書式】\ncallmenu <menu ID>\n\n【解説】\n<menu ID> で指定されたメニューを実行する。ID については Keycode を参照。\n\n
changedir /// 【コマンド】\nchangedir\n\n【概要】\nTera Term の現在のディレクトリを変更する。\n\n【書式】\nchangedir <path>\n\n【解説】\nTera Term の現在のディレクトリを <path> に変更する。\n\n注意: setdir コマンドは MACRO の現在のディレクトリを変更する。通信コマンド(kmtsend 等)で指定されるファイル名は Tera Term の現在のディレクトリを基準にする。その他のコマンド(fileopen 等)で指定されるファイル名は MACRO の現在のディレクトリを基準にする。\n\n補足: 通信コマンド（sendfile, kmtsend等）に指定されるファイル名は、changedirコマンドの影響を受けないため、絶対パスである必要がある。\n\n
clearscreen /// 【コマンド】\nclearscreen\n\n【概要】\nウインドウの画面を消去する。\n\n【書式】\nclearscreen <int>\n\n【解説】\n<int> が0の場合、 Tera Term の VT ウインドウの画面を消去する。\n<int> が1の場合、 Tera Term の VT ウインドウのスクロールバッファーの内容と画面を消去する。\n<int> が2の場合、 Tera Term の TEK ウインドウの画面を消去する。\n\n
closett /// 【コマンド】\nclosett\n\n【概要】\nTera Term を終了させる。\n\n【書式】\nclosett\n\n【解説】\nTera Term を終了させ、 MACRO は非リンク状態に入る。\n非リンク状態では、connect コマンドによって新しい Tera Term ウィンドウを開き、MACRO をそれにリンクさせることができる。\n\nConfirmDisconnectの設定有無に関係なく、常に TCP/IP 回線切断の確認をしない。\n\n
connect /// 【コマンド】\nconnect\n\n【概要】\n接続する。\n\n【書式】\nconnect <command line parameters>\n\n【解説】\nMACRO が Tera Term とリンクされていない場合、Tera Term を起動してMACRO とリンクする。<command line parameters> は、Tera Term を起動する時のコマンドラインパラメータ。\n\nMACRO が Tera Term とすでにリンクされていて、Tera Term がホストに接続されていない場合、Tera Term をコマンドライン <command line parameters> で指定されるホストに接続させる。Tera Term のコマンドラインパラメータについては、"Tera Term Pro コマンドライン"、"TTSSH コマンドライン"を参照。\n\nMACRO が Tera Term とすでにリンクされていて、Tera Term がホストにすでに接続されている場合、このコマンドは無視される。\n\nこのコマンドの結果、リンクと接続の状態に応じて以下のうちの一つの値がシステム変数 result に格納される。\n\n値	状態\n0	Tera Term とリンクされていない。\n1	ホストへの接続はされていないが、Tera Term へのリンクはされている。\n2	リンクおよび接続両方ともされている。\n"connect" コマンドを実行する前にリンクと接続の状態を調べるには、"testlink" コマンドを使うことができる。\n\nTera Term と MACRO のリンクしていない状態では、"connect" と "cygconnect", "testlink" 以外の通信コマンドは実行できない。\n\n
cygconnect /// 【コマンド】\ncygconnect\n\n【概要】\nCygwinへ接続する。\n\n【書式】\ncygconnect [<command line parameters>]\n\n【解説】\nMACRO が Tera Term とリンクされていない場合、Cygwin に接続した Tera Term を起動して MACRO とリンクする。<command line parameters> は、Cygwin に接続する時に使う CygTerm のコマンドラインパラメータ。CygTerm のコマンドラインパラメータについては、"CygTerm+ コマンドライン"を参照。\n\nMACRO が Tera Term とすでにリンクされていて、Tera Term がホストに接続されていない場合、リンクしている Tera Term を終了させた後、cygwin に接続した状態の Tera Termを 起動して MACRO とリンクする。\n\nMACRO が Tera Term とすでにリンクされていて、Tera Term がホスト又は Cygwin にすでに接続されている場合、このコマンドは無視される。\n\nこのコマンドの結果、リンクと接続の状態に応じて以下のうちの一つの値がシステム変数 result に格納される。\n\n値	状態\n0	Tera Term とリンクされていない。\n1	ホスト又は cygwin への接続はされていないが、Tera Term へのリンクはされている。\n2	リンクおよび接続両方ともされている。\n"cygconnect" コマンドを実行する前にリンクと接続の状態を調べるには、"testlink" コマンドを使うことができる。\n\nTera Term と MACRO のリンクしていない状態では、"connect" と "cygconnect", "testlink" 以外の通信コマンドは実行できない。\n\n
disconnect /// 【コマンド】\ndisconnect\n\n【概要】\nTera Term とホストの間の通信を終了させる。\n\n【書式】\ndisconnect [<confirm>]\n\n【解説】\n整数 <confirm> (オプション デフォルト=非ゼロ) (バージョン 4.65 以降)\n0を指定すると、TCP/IP 接続切断時の確認ダイアログを表示せずに通信を終了する。\n0以外の値を指定すると、TCP/IP 接続切断時の確認ダイアログを表示する。\n解説\n\nもしこのコマンドによって Tera Term が終了しなければ、Tera Term と MACRO の間のリンクは保持される。\n\n
dispstr /// 【コマンド】\ndispstr\n\n【概要】\n文字を端末画面に出力する。\n\n【書式】\ndispstr <data1> [<data2>....]\n\n【解説】\n<data> が文字列型の場合、文字列をそのまま端末画面に表示する。\n<data> が整数型の場合は、その値の下位バイト(0-255)を ASCII コードとして扱い、対応する文字を端末画面に表示する。\n\n注意\n\n当該コマンドの出力内容はホスト側からは認識できない。そのため、当該コマンドを使用すると、端末画面の表示状態がホスト側とずれてしまい、端末画面の表示が崩れる可能性がある。\n\nTera Termは接続状態でないと、マクロコマンドは実行されない。\n\n
enablekeyb /// 【コマンド】\nenablekeyb\n\n【概要】\nTera Term のキーボード入力を許可/禁止する。\n\n【書式】\nenablekeyb <flag>\n\n【解説】\n<flag> の値が1の場合は許可、0の場合は禁止。\n禁止にすると、マクロからのデータ送信中に、ユーザの誤入力を防ぐことができる。\n\n
flushrecv /// 【コマンド】\nflushrecv\n\n【概要】\nMACRO の受信バッファーの内容を消す。\n\n【書式】\nflushrecv\n\n【解説】\nホストから受信した文字は MACRO に転送され、MACRO の受信バッファーに保存される。\n受信文字を処理するコマンド("wait" コマンド等)はそれらの文字をバッファーから読み出す。\nバッファーの中の文字は受信文字を処理するコマンドがそれらを読みだすか、バッファーがあふれるか、flushrecv コマンドがバッファーの内容を消すまで保持される。\n\nバッファーの中に古い文字がたまっているために受信文字を処理するコマンドの結果が予期しないものになることがあり、flushrecv コマンドによってそれを防ぐことができる。\n\n参照: setsync\n\n
gethostname /// 【コマンド】\ngethostname\n\n【概要】\n接続先のホスト名（IPアドレス）を得る。\n\n【書式】\ngethostname <strvar>\n\n【解説】\nTera Term が接続しているホスト名（IPアドレス）を、文字列変数 <strvar> に格納する。\n\n
getmodemstatus /// 【コマンド】\ngetmodemstatus\n\n【概要】\nモデムの制御レジスタ値を取得する。\n\n【書式】\ngetmodemstatus <intvar>\n\n【解説】\nシリアルポートからモデム制御レジスタの値を読み出す。\n\n<intvar> 変数は、下記の定数の組み合わせとなる。\n1  CTS（ 送信可）信号がオンです。\n2  DSR（ データセットレディ）信号がオンです。\n4  呼び出し信号がオンです。\n8  RLSD（ 受信線信号検出）信号がオンです。\n読み出しに成功した場合は result 変数が 0 となるが、失敗した場合は 1 となる。\n\n
gettitle /// 【コマンド】\ngettitle\n\n【概要】\nウインドウタイトル文字列を得る。\n\n【書式】\ngettitle <strvar>\n\n【解説】\nTera Term のウィンドウタイトルを文字列変数 <strvar> に格納する。\n\n
kmtfinish /// 【コマンド】\nkmtfinish\n\n【概要】\nKermit Finish コマンドを実行する。\n\n【書式】\nkmtfinish\n\n【解説】\nFinish コマンドが終了するまで次のコマンドは実行されない。\nFinish コマンドが正しく実行された場合、システム変数 result に1が格納される。それ以外の場合、 result に0が格納される。\n\n
kmtget /// 【コマンド】\nkmtget\n\n【概要】\nファイルを Kermit Get コマンドで受信する。\n\n【書式】\nkmtget <filename>\n\n【解説】\nファイル を Kermit Get コマンドを使用してホストから受信する。\nホストは server 状態でなければならない。 受信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に1が格納される。それ以外の場合、 result に0が格納される。\n\n
kmtrecv /// 【コマンド】\nkmtrecv\n\n【概要】\nKermit プロトコルでファイルを受信する。\n\n【書式】\nkmtrecv\n\n【解説】\n受信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に1が格納される。それ以外の場合、 result に0が格納される。\n\n
kmtsend /// 【コマンド】\nkmtsend\n\n【概要】\nファイルをKermit プロトコルで送信する。\n\n【書式】\nkmtsend <filename>\n\n【解説】\nファイル <filename> を Kermit プロトコルで送信する。\n送信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に1が格納される。それ以外の場合、 result に0が格納される。\n\n
loadkeymap /// 【コマンド】\nloadkeymap\n\n【概要】\nキーボード設定ファイルを読み込む。\n\n【書式】\nloadkeymap <filename>\n\n【解説】\nキーボード設定ファイル <filename> を Tera Term に読み込ませる。\n\n
logautoclosemode /// 【コマンド】\nlogautoclosemode\n\n【概要】\nマクロ終了時、自動的にログ採取を停止する。\n\n【書式】\nlogautoclosemode <flag>\n\n【解説】\n<flag> の値が1の場合、マクロ終了時、自動的にログ採取を停止する。\n<flag> の値が0の場合、マクロ終了時、自動的にログ採取を停止しない。\n\n※マクロ終了後、設定情報はデフォルトに戻す。すなわち、マクロ終了時、自動的にログ採取を停止しない。\n\n
logclose /// 【コマンド】\nlogclose\n\n【概要】\nTera Term のログを終了する。\n\n【書式】\nlogclose\n\n【解説】\nlogopen\n\n
loginfo /// 【コマンド】\nloginfo\n\n【概要】\nTera Term のログ取得状態を得る\n\n【書式】\nloginfo <strvar>\n\n【解説】\nログを取得している場合、strvar にログファイル名が格納され、ログ取得時のフラグの状態が result に格納される。\nログを取得していない場合は result に -1 が格納される。\n\nログ取得時に result に格納される値は、以下の内 on になっているフラグに対応する値の合計となる。\n\n値	意味\n1	バイナリフラグ\n2	アペンドフラグ\n4	プレインテキストフラグ\n8	タイムスタンプフラグ\n16	ダイアログ非表示フラグ\n\n\n
logopen /// 【コマンド】\nlogopen\n\n【概要】\nTera Term のログを開始する。\n\n【書式】\nlogopen <filename> <binary flag> <append flag> [<plain text flag> [<timestamp flag> [<hide dialog flag> [<Include screen buffer>]]]]\n\n【解説】\nファイル <filename> に受信した文字が書き込まれる。ログを開始したあとも次のコマンドは実行される。\nファイル名に \ を含まない場合、Tera Termのカレントディレクトリに作成される。当該ディレクトリを変更するには changedir マクロを使用する。\n\n<binary flag> の値が0のとき、受信した漢字、改行文字は変換されてファイルに書き込まれ、エスケープシーケンスは書き込まれない。\n<binary flag> の値が0以外のとき、受信した文字をすべてそのままファイルに書き込む。\n\n<append flag> の値が0以外で、ファイル <filename> がすでに存在する場合、そのファイルに追加して書き込む。\n<append flag> の値が0で、ファイル <filename> がすでに存在する場合、そのファイルは上書きされる。\n\n<plain text flag> が 0 以外の場合、ASCII 非表示文字をログに書き込まない。\n<timestamp flag> が 0 以外の場合、ログの行頭に時刻を追加する。\nただし、<binary flag> が 0 以外の場合、<plain text flag>, <timestamp flag> は両方とも無視される。バイナリログはログ再生に利用可能。 (バージョン 4.61以降)\n\n<hide dialog flag> が 0 以外の場合、ログ転送のダイアログを表示しない。\n\n<Include screen buffer> が 0 以外の場合、現在の端末バッファすべてを先にファイルに書き込む。 (バージョン 4.80以降)\n\nログファイルを開けた場合、result に 0 が格納される。開けなかった場合は 1 が格納される。(バージョン 4.62 以降)\n\n
logpause /// 【コマンド】\nlogpause\n\n【概要】\nTera Term のログを一時中断する。\n\n【書式】\nlogpause\n\n【解説】\n中断している間に受信された文字はログファイルに書き込まれない。\n\n
logrotate /// 【コマンド】\nlogrotate\n\n【概要】\nログをローテートする。\n\n【書式】\nlogrotate 'size' '<size>'\n\n【解説】\nパラメータ\n\n'size' '<size>'\nログのサイズが<size>バイトを超えていれば、ローテーションを行う。\n<size>は128以上であること。\n末尾に"K"があるとキロバイト単位、"M"があるとメガバイト単位になる。\n'rotate' <count>\nログファイルの世代を<count>にする。\n<count>は1以上であること。\n'halt'\nローテーションを停止する。\n注意\n\n事前にログファイルがオープンされている必要があります。\n本コマンドは、ログのローテートの設定を行うのみで、ローテート処理が即時実行されるわけではありません。\n\n
logstart /// 【コマンド】\nlogstart\n\n【概要】\n中断していた Tera Term のログを再開する。\n\n【書式】\nlogstart\n\n【解説】\nlogpauseを参照。\n\n
logwrite /// 【コマンド】\nlogwrite\n\n【概要】\n文字列をログに書き込む。\n\n【書式】\nlogwrite <string>\n\n【解説】\n文字列 <string> を Tera Term のログファイルに追加して書き込む。\nこのコマンドは Tera Term がログを取っている時だけ有効。ログを一時中断している時でも書き込むことができる。\n\n空文字列の場合は syntax error となる。\n\n例\n\nlogopenを参照。\n\n
quickvanrecv /// 【コマンド】\nquickvanrecv\n\n【概要】\nQuick-VAN プロトコルでファイルを受信する。\n\n【書式】\nquickvanrecv\n\n【解説】\nQuick-VAN プロトコルでファイルを受信する。\n受信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に1が格納される。それ以外の場合、 result に0が格納される。\n\n
quickvansend /// 【コマンド】\nquickvansend\n\n【概要】\nQuick-VAN プロトコルでファイルを送信する。\n\n【書式】\nquickvansend <filename>\n\n【解説】\nファイル <filename> を Quick-VAN プロトコルで送信する。\n送信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に1が格納される。それ以外の場合、 result に0が格納される。\n\n
recvln /// 【コマンド】\nrecvln\n\n【概要】\n一行分の文字を受信する。\n\n【書式】\nrecvln\n\n【解説】\nホストから一行分の文字を受信し、システム変数 inputstr に格納する。\nこのコマンドは一行受信するか、Tera Term とホストの通信が終了するか、タイムアウトが起きるまで待つ。\n\nシステム変数 timeout か mtimeout が 0 より大きい場合、<timeout>.<mtimeout> 秒の時間がすぎるとタイムアウトが発生する。タイムアウトの値が 0 以下の場合は、タイムアウトは発生しない。\n\nもし、一行分の文字が受信された場合、システム変数 result に1が格納される。そうでない場合 result に0が格納される。\n\n
restoresetup /// 【コマンド】\nrestoresetup\n\n【概要】\n設定ファイルを読み込む。\n\n【書式】\nrestoresetup <filename>\n\n【解説】\nTera Term 設定ファイル <filename> を Tera Term に読み込ませる。\n\n
scprecv /// 【コマンド】\nscprecv\n\n【概要】\nSCPプロトコルでファイルを受信する。\n\n【書式】\nscprecv <remote filename> [<local filename>]\n\n【解説】\nファイル <remote filename> を SCP(Secure Copy Protocol) プロトコルで受信する。 ローカルファイル <local filename> を省略した場合は、ファイルはローカルホストのカレントディレクトリへコピーされる。 受信が終わるのを待たずに、次のコマンドを実行することができる。\n\n
scpsend /// 【コマンド】\nscpsend\n\n【概要】\nSCPプロトコルでファイルを送信する。\n\n【書式】\nscpsend <filename> [<destination filename>]\n\n【解説】\nファイル <filename> を SCP(Secure Copy Protocol) プロトコルで送信する。 転送先を省略した場合は、ファイルはリモートホストのホームディレクトリへコピーされる。 送信が終わるのを待たずに、次のコマンドを実行することができる。\n\n
send /// 【コマンド】\nsend\n\n【概要】\nデータを送信する。\n\n【書式】\nsend <data1> <data2>....\n\n【解説】\n<data> が文字列型の場合、文字列をホストへ送信させる。\n<data> が整数型の場合は、その値の下位バイト(0-255)を ASCII コードとみなし、その文字を送信させる。\n\n
sendbreak /// 【コマンド】\nsendbreak\n\n【概要】\nブレーク信号をホストへ送出する。\n\n【書式】\nsendbreak\n\n【解説】\nシリアルコンソールでは、ホスト側にブレーク割り込み(Break interrupt indicator)を発生させる。TELNETでは、IAC BREAK(255 243)を送信する。SSH2では、SSH2_MSG_CHANNEL_REQUEST("break")を送信する。\n\n
sendbroadcast /// 【コマンド】\nsendbroadcast\n\n【概要】\nデータをブロードキャスト送信する。\n\n【書式】\nsendbroadcast <data1> <data2>....\n\n【解説】\n<data> をすべての端末にブロードキャスト送信し、端末からホストへ送信させる。\n<data> が文字列型の場合、文字列を送信させる。\n<data> が整数型の場合は、その値の下位バイト(0-255)を ASCII コードとみなし、その文字を送信させる。\n\n※AcceptBroadcastが無効の端末では、送信データが破棄されます。\n\n
sendfile /// 【コマンド】\nsendfile\n\n【概要】\nファイルを送信する。\n\n【書式】\nsendfile <filename> <binary flag>\n\n【解説】\n<filename> で指定されたファイルを送信する。送信が終わるまで次のコマンドは実行されない。\n<binary flag> の値が 0 以外のとき、ファイルの内容をそのまま送信する。\n<binary flag> の値が 0 のとき、ファイルの中に含まれる漢字、改行文字を変換して送信する。TAB ($09), LF ($0A), CR ($0D) 以外の制御文字は送信されない。\n\n
sendkcode /// 【コマンド】\nsendkcode\n\n【概要】\nキーコードを送信する。\n\n【書式】\nsendkcode <key code> <repeat count>\n\n【解説】\nあるキーまたはキーの組み合わせを押すことに対して割り当てられた機能を Tera Term に実行させる。\nそのキーまたはキーの組み合わせはKEYCODE.EXE によって定義されるキーコード <key code>で指定される。その機能は <repeat count> 回繰り返して実行される。\n\n通常、その機能とは文字または文字列をホストへ送出するということ。その機能は Tera Term のキーボード設定ファイルによって定義することができる。\nKEYCODE.TXT 参照。\n\n
sendln /// 【コマンド】\nsendln\n\n【概要】\nデータと改行を送信する。\n\n【書式】\nsendln <data1> <data2>....\n\n【解説】\n文字列とそれに続く改行文字をホストへ送信させる。\n<data> の形式は、"send"コマンドと同じ。\n\n
sendlnbroadcast /// 【コマンド】\nsendlnbroadcast\n\n【概要】\nデータをブロードキャスト送信する。\n\n【書式】\nsendlnbroadcast <data1> <data2>....\n\n【解説】\n文字列とそれに続く改行文字を、すべての端末にブロードキャスト送信し、端末からホストへ送信させる。\n<data> の形式は、"sendbroadcast"コマンドと同じ。\n\n※AcceptBroadcastが無効の端末では、送信データが破棄されます。\n\n
sendlnmulticast /// 【コマンド】\nsendlnmulticast\n\n【概要】\nデータと改行をマルチキャスト送信する。\n<data> の形式は、"sendmulticast"コマンドと同じ。\n\n【書式】\nsendlnmulticast <multicastname> <data1> <data2>....\n\n【解説】\n文字列とそれに続く改行文字を、指定した端末にマルチキャスト送信する。\n<data> の形式は、"sendmulticast"コマンドと同じ。\n\n
sendmulticast /// 【コマンド】\nsendmulticast\n\n【概要】\nデータをマルチキャスト送信する。\n\n【書式】\nsendmulticast <multicastname> <data1> <data2>....\n\n【解説】\n<data> を <multicastname> 引数で指定した端末へマルチキャスト送信し、端末からホストへ送信させる。\n端末の識別は、setmulticastnameコマンドかコマンドラインオプションで事前に設定しておく。\n<data> が文字列型の場合、文字列を送信させる。\n<data> が整数型の場合は、その値の下位バイト(0-255)を ASCII コードとみなし、その文字を送信させる。\n\n※AcceptBroadcastが無効の端末では、送信データが破棄されます。\n\n
setbaud /// 【コマンド】\nsetbaud\n\n【概要】\nシリアルポートのボーレートを変更する。\n\n【書式】\nsetbaud <value>\n\n【解説】\n整数 <value> (バージョン 4.66 未満)\nボーレートに対応するIDを指定する。\nID       baud rate\n1        110 \n2        300 \n3        600 \n4        1200 \n5        2400 \n6        4800 \n7        9600 \n8        14400 \n9        19200 \n10       38400 \n11       57600 \n12       115200 \n13       230400 \n14       460800 \n15       921600 \n整数 <value> (バージョン 4.66 以降)\nボーレートを指定する。\n\n
setdebug /// 【コマンド】\nsetdebug\n\n【概要】\nデバッグモードを設定する。\n\n【書式】\nsetdebug <flag>\n\n【解説】\n以下のフラグにより、Tera Termのデバッグモードを設定する。デバッグモードを有効にすることで、"wait"コマンドで「制御コード」を待つことができる。 \n\n0: デバッグモード無効。通常出力を行う。\n1: 従来のデバッグモード（詳細はこちら）\n2: 16進出力モード。受信データを大文字の16進数で、空白をあけて表示する。\n3: 出力を一切しない。\n\n
setdtr /// 【コマンド】\nsetdtr\n\n【概要】\nTera Term で DTR(Data Terminal Ready) の状態を変更する。\n\n【書式】\nsetdtr <flag>\n\n【解説】\n接続がシリアル接続ではない場合やフロー制御が none でない場合には、このコマンドは何も行わない。\n\nもし <flag> が0なら DTR は off になる。\nもし <flag> が0以外なら DTR は on になる。\n\n
setecho /// 【コマンド】\nsetecho\n\n【概要】\nTera Term のローカルエコー (local echo) の状態を変更する。\n\n【書式】\nsetecho <echo flag>\n\n【解説】\nもし <echo flag> が0以外ならローカルエコーは on になる。\nもし <echo flag> が0ならローカルエコーは off になる。\n\n
setflowctrl /// 【コマンド】\nsetflowctrl\n\n【概要】\nシリアルポートのフロー制御を変更する。\n\n【書式】\nsetflowctrl <value>\n\n【解説】\n整数 <value>\n　以下のフラグにより、シリアルポートのフロー制御を指定する。\n　値　意味\n　1　Xon/Xoff\n　2　hardware\n　3　none\n\n
setmulticastname /// 【コマンド】\nsetmulticastname\n\n【概要】\nマルチキャスト送信のための端末識別名を設定する。\n\n【書式】\nsetmulticastname <multicastname>\n\n【解説】\n自身の端末に対して、<multicastname>引数で指定した名前を識別子として設定する。\n\nsendmulticastを参照。\n\n
setrts /// 【コマンド】\nsetrts\n\n【概要】\nTera Term で RTS(Request To Send) の状態を変更する。\n\n【書式】\nsetrts <flag>\n\n【解説】\n接続がシリアル接続ではない場合やフロー制御が none でない場合には、このコマンドは何も行わない。\n\nもし <flag> が0なら RTS は off になる。\nもし <flag> が0以外なら RTS は on になる。\n\n
setspeed /// 【コマンド】\nsetspeed\n\n【概要】\nシリアルポートのスピードを変更する。\nこのコマンドは setbaud のエイリアスです。\n\n【書式】\nsetspeed <value>\n\n【解説】\nシリアルポートのスピードを <value> bps に変更します。\n\n
setsync /// 【コマンド】\nsetsync\n\n【概要】\n同期モードを設定する。\n\n【書式】\nsetsync <sync flag>\n\n【解説】\n<sync flag> が0以外ならば同期通信モードに入る。\n<sync flag> が0ならば非同期通信モードに入る。\n\nTera Term はホストから受信した文字を MACRO へ転送する。\nMACRO はそれらの文字をバッファに保存し、受信文字を処理するコマンド("wait" コマンド等)がバッファから文字を取り出す。\n\nMACRO は初期状態が「非同期モード」である。このモードでは、受信文字を処理するコマンドが長い間実行されない場合、または受信速度が速すぎる場合はバッファがあふれる可能性がある。\n同期モードでは、バッファは決してあふれない。バッファがいっぱいになった場合、Tera Term はホストからの文字受信と MACRO への文字転送を停止する。バッファに再び空きができると Tera Term は文字受信と転送を再開する。\n必要な時に限り同期モードに入り、必要でなくなったら非同期モードに戻るようにした方が良い。\n\n複数行にわたる受信した文字を、一文字も失うことなく処理する、というような信頼性が要求されるマクロ処理の場合、同期モードに入る必要がある。\nしかし、同期モードでは Tera Term の文字受信速度が遅くなり、また受信文字を処理するコマンドが長い間実行されない場合は、Tera Term の文字受信が停止したままになってしまう。\n一方、単純なマクロ処理(例えば自動ログイン)ならば非同期モードでもほとんど問題なく動作する。この場合、バッファサイズは十分大きく(16Kバイト)、受信したすべての文字はバッファがあふれる前にコマンドによって処理される。\n\n\nバッファのクリアについては "flushrecv" を参照。\n\n
settitle /// 【コマンド】\nsettitle\n\n【概要】\nウインドウタイトル文字列を変更する。\n\n【書式】\nsettitle <title>\n\n【解説】\nTera Term のウィンドウタイトルを <title> に変更する。\n\n
showtt /// 【コマンド】\nshowtt\n\n【概要】\nTera Term ウインドウの表示状態を変更する。\n\n【書式】\nshowtt <show flag>\n\n【解説】\n<show flag> が-1の場合、 Tera Term の VT ウインドウを隠す。\n<show flag> が0の場合、 Tera Term の VT ウインドウを最小化する。\n<show flag> が1の場合、 Tera Term の VT ウインドウを元の大きさに戻す。\n<show flag> が2の場合、 Tera Term の TEK ウインドウを隠す。\n<show flag> が3の場合、 Tera Term の TEK ウインドウを最小化する。\n<show flag> が4の場合、 Tera Term の TEK ウインドウを開く、または元の大きさに戻す。\n<show flag> が5の場合、 Tera Term の TEK ウインドウを閉じる。\n<show flag> が6の場合、 ログウィンドウを隠す。\n<show flag> が7の場合、 ログウィンドウを最小化する。\n<show flag> が8の場合、 ログウィンドウを元の大きさに戻す。\n\n
testlink /// 【コマンド】\ntestlink\n\n【概要】\n現在のリンクおよび接続の状態を報告する。\n\n【書式】\ntestlink\n\n【解説】\nリンクと接続の状態に応じて以下のうちの一つの値がシステム変数 result に格納される。\n\n値	状態\n0	Tera Term とリンクされていない。\n1	ホストへの接続はされていないが、Tera Term へのリンクはされている。\n2	リンクおよび接続両方ともされている。\n\n
unlink /// 【コマンド】\nunlink\n\n【概要】\n現在の Tera Term ウインドウと MACRO の間のリンクを断つ。\n\n【書式】\nunlink\n\n【解説】\nこのコマンド以降、MACRO は非リンク状態になり、その Tera Term ウインドウを制御できなくなる。\n非リンク状態では、connect コマンドによって新しい Tera Term ウィンドウを開き、MACRO をそれにリンクさせることができる。\n\n
wait /// 【コマンド】\nwait\n\n【概要】\n文字列を待つ。\n\n【書式】\nwait <string1> [<string2> ...]\n\n【解説】\n文字列 <string1> [<string2> ...] のうち一つがホストから送られてくるか、タイムアウトが発生するまで MACRO を停止させる。文字列は最大 10 個まで指定できる。\n\n空文字列が指定された場合、任意の一文字を受信するのを待つ。\n\nシステム変数 timeout か mtimeout が 0 より大きい場合、<timeout>.<mtimeout> 秒の時間がすぎるとタイムアウトが発生する。タイムアウトの値が 0 以下の場合は、タイムアウトは発生しない。\n\nこれらのコマンドの実行結果はシステム変数 result に格納される。変数 result の値の意味は以下のとおり。\n\n値	意味\n0	タイムアウト。どの文字列も来なかった。\n1	<string1> を受信した。\n2	<string2> を受信した。\nn	<stringn> を受信した。n=1..10\n\n
wait4all /// 【コマンド】\nwait4all\n\n【概要】\nマクロに接続されている全端末の文字列を待つ。\n\n【書式】\nwait4all <string1> [<string2> ...]\n\n【解説】\n当該コマンドを実行した時点における、マクロに接続されている全端末において、 文字列 <string1> [<string2> ...] のうち一つがホストから送られてくるか、タイムアウトが発生するまで MACRO を停止させる。文字列は最大 10 個まで指定できる。\n当該コマンドを実行した後に起動された端末、マクロ接続されていない端末に関しては、監視対象外となる。\n\nシステム変数 timeout か mtimeout が 0 より大きい場合、<timeout>.<mtimeout> 秒の時間がすぎるとタイムアウトが発生する。タイムアウトの値が 0 以下の場合は、タイムアウトは発生しない。\n\nこれらのコマンドの実行結果はシステム変数 result に格納される。変数 result の値の意味は以下のとおり。\n\n値	意味\n0	タイムアウト。どの文字列も来なかった。\n1	<string1> を受信した。\n2	<string2> を受信した。\nn	<stringn> を受信した。n=1..10\nなお、当該コマンドを利用するためには、teraterm.ini の Wait4allMacroCommand エントリを"on"にする必要がある。また、まれにコマンドが期待通りに動かないことがある。\n\n
waitevent /// 【コマンド】\nwaitevent\n\n【概要】\nイベントを待つ。\n\n【書式】\nwaitevent <events>\n\n【解説】\n<events> で指定されるイベントが発生するまで MACRO を停止させる。<events> は以下のイベント識別子の組み合わせ。\n\nイベント	イベント識別子\ntimeout	1\nunlink	2\ndisconnection	4\nconnection	8\nシステム変数 timeout か mtimeout が 0 より大きい場合、<timeout>.<mtimeout> 秒の時間がすぎると(タイムアウト)イベントが発生する。タイムアウトの値が 0 以下の場合は、タイムアウトは発生しない。\n\nunlink イベントは Tera Term が閉じられたときに発生する。\n\ndisconnection (または connection) イベントは、Tera Term とホストの間の通信が閉じられた(開かれた)時に発生する。\n\nこれらのコマンドは実際に発生したイベントの識別子をシステム変数 result に格納する。\n\n
waitln /// 【コマンド】\nwaitln\n\n【概要】\n文字列を含む行を待つ。\n\n【書式】\nwaitln <string1> [<string2> ...]\n\n【解説】\n文字列 <string1>, [<string2>, ...] のうち一つを含む行をホストから受信するか、タイムアウトが発生するまで MACRO を停止させる。文字列は最大 10 個まで指定できる。\n\n空文字列が指定された場合、任意の一文字（＋改行）を受信するのを待つ。\n\nシステム変数 timeout か mtimeout が 0 より大きい場合、<timeout>.<mtimeout> 秒の時間がすぎるとタイムアウトが発生する。タイムアウトの値が 0 以下の場合は、タイムアウトは発生しない。\n\nこれらのコマンドは受信した行をシステム変数 inputstr に格納し、以下の値をシステム変数 result に格納する。\n\n値	意味\n0	タイムアウト。\n1	<string1> を含む行を受信した。\n2	<string2> を含む行を受信した。\nn	<stringn> を含む行を受信した。n=1..10\n\n\n
waitn /// 【コマンド】\nwaitn\n\n【概要】\n指定されたバイト数の受信を待つ。\n\n【書式】\nwaitn <received byte count>\n\n【解説】\n引数に指定したバイト数以上のデータが受信されるまで、待つ。\n\nシステム変数 timeout か mtimeout が 0 より大きい場合、<timeout>.<mtimeout> 秒の時間がすぎるとタイムアウトが発生する。タイムアウトの値が 0 以下の場合は、タイムアウトは発生しない。\n\nこれらのコマンドの実行結果はシステム変数 result に格納される。変数 result の値の意味は以下のとおり。\n\n値	意味\n0	1文字も来ずにタイムアウトが発生した。\n1	指定されたバイト数の文字が来て、 inputstr に保存された。\n指定されたバイト数が 511 を越える場合は、最初の 511 バイトのみが inputstr に保存される。\n\n\n
waitrecv /// 【コマンド】\nwaitrecv\n\n【概要】\n文字列を待つ。\n\n【書式】\nwaitrecv <sub-string> <len> <pos>\n\n【解説】\nある条件を満たす 1 つの文字列がホストから送られてくるか、タイムアウトが発生するまで、 MACRO を停止させる。\n\nその条件とは、文字列の長さが <len> 文字で、文字列がその <pos> 文字目（1オリジン）から始まる副文字列 <sub-string> を含んでいるということ。\n例えば、<sub-string> が "def"、<len> が 9 、<pos> が 4 のとき、文字列 "abcdefghi" は条件を満たす。\n\nもし条件を満たす文字列が送られてきたら、システム変数 inputstr に保存される。\n\nシステム変数 timeout か mtimeout が 0 より大きい場合、<timeout>.<mtimeout> 秒の時間がすぎるとタイムアウトが発生する。タイムアウトの値が 0 以下の場合は、タイムアウトは発生しない。\n\nこれらのコマンドの実行結果はシステム変数 result に格納される。変数 result の値の意味は以下の通り。\n\n値	意味\n-1	<pos> 文字目から始まる <sub-string> を含む文字列が来て、inputstr に保存された。しかし文字列の長さは、タイムアウトのために <len> 文字より短い。\n0	タイムアウト。条件を満たす文字列は送られてこなかった。\n1	条件をみたす文字列が来て、 inputstr に保存された。\n\n
waitregex /// 【コマンド】\nwaitregex\n\n【概要】\n正規表現文字列を含む行を待つ。\n\n【書式】\nwaitregex <string1 with regular expression> [<string2 with regular expression> ...]\n\n【解説】\nOniguruma の正規表現 が使用できます。\n正規表現文字列のうち 1 つ以上を含む行（最大 511 文字）をホストから受信するか、タイムアウトが発生するまで MACRO を停止させる。正規表現文字列は最大 10 個まで指定できる。\n\nシステム変数 timeout か mtimeout が 0 より大きい場合、<timeout>.<mtimeout> 秒の時間がすぎるとタイムアウトが発生する。タイムアウトの値が 0 以下の場合は、タイムアウトは発生しない。\n\nこれらのコマンドの実行結果はシステム変数 result , inputstr, matchstr に格納される。変数 result の値の意味は以下のとおり。\n\n値	意味\n0	タイムアウト。どの文字列も来なかった。\n1	<string1 with regular expression> を受信した。\n2	<string2 with regular expression> を受信した。\nn	<stringn with regular expression> を受信した。n=1..10\n変数 inputstr には受信した行が格納される。\n変数 matchstr には最初にマッチしたパターンが格納される。\n変数 groupmatchstr1〜groupmatchstr9 にはグループマッチしたパターンが格納される。\n\n日本語等のマルチバイト文字列を待つ場合、事前にregexoptionで適切なエンコーディングを設定しておく必要がある。\n\n
xmodemrecv /// 【コマンド】\nxmodemrecv\n\n【概要】\nXMODEM プロトコルでファイルを受信する。\n\n【書式】\nxmodemrecv <filename> <binary flag> <option>\n\n【解説】\nXMODEM プロトコルでファイル <filename> を受信する。受信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に 1 が格納される。それ以外の場合、 result に 0 が格納される。\n\nファイルがバイナリファイルの場合は、<binary flag> は 0 以外でなければならない。\nテキストファイルの場合は、<binary flag> は 0 でなければならない。\n<option> によって、XMODEM のオプションを指定する。\n\n<option>	XMODEM オプション\n1	Checksum\n2	CRC\n3	1K\nそれ以外	Checksum\n\n
xmodemsend /// 【コマンド】\nxmodemsend\n\n【概要】\nXMODEM プロトコルでファイルを送信する。\n\n【書式】\nxmodemsend <filename> <option>\n\n【解説】\nXMODEM プロトコルでファイル <filename> を送信する。送信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に 1 が格納される。それ以外の場合、 result に 0 が格納される。\n\n<option> によって、XMODEM のオプションを指定する。\n\n<option>	XMODEM オプション\n1	Checksum\n2	CRC\n3	1K\nそれ以外	Checksum\n\n
ymodemrecv /// 【コマンド】\nymodemrecv\n\n【概要】\nYMODEM プロトコルでファイルを受信する。\n\n【書式】\nymodemrecv\n\n【解説】\n受信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に 1 が格納される。それ以外の場合、 result に 0 が格納される。\n\n参照\n\nymodemsend\n\n
ymodemsend /// 【コマンド】\nymodemsend\n\n【概要】\nYMODEM プロトコルでファイルを送信する。\n\n【書式】\nymodemsend <filename>\n\n【解説】\nファイル <filename> を YMODEM プロトコルで送信する。送信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に1が格納される。それ以外の場合、 result に0が格納される。\n\n
zmodemrecv /// 【コマンド】\nzmodemrecv\n\n【概要】\nZMODEM プロトコルでファイルを受信する。\n\n【書式】\nzmodemrecv\n\n【解説】\n受信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に 1 が格納される。それ以外の場合、 result に 0 が格納される。\n\n参照\n\nzmodemsend\n\n
zmodemsend /// 【コマンド】\nzmodemsend\n\n【概要】\nZMODEM プロトコルでファイルを送信する。\n\n【書式】\nzmodemsend <filename> <binary flag>\n\n【解説】\nファイル <filename> を ZMODEM プロトコルで送信する。送信が終わるまで次のコマンドは実行されない。\nファイルが正しく転送された場合、システム変数 result に1が格納される。それ以外の場合、 result に0が格納される。\n\nファイルがバイナリファイルの場合は、<binary flag> は 0 以外でなければならない。\nテキストファイルの場合は、<binary flag> は0でなければならない。\n\n

●制御コマンド
break /// 【コマンド】\nbreak\n\n【概要】\nループから抜ける。\n\n【書式】\nbreak\n\n【解説】\n"for" や "while" のループから抜ける。\n\n
call /// 【コマンド】\ncall\n\n【概要】\nサブルーチンをコールする。\n\n【書式】\ncall <label>\n\n【解説】\n<label> 行から始まるサブルーチンをコールする。\n\n
continue /// 【コマンド】\ncontinue\n\n【概要】\nループの次の反復処理に移る。\n\n【書式】\ncontinue\n\n【解説】\n"for" や "while" のループの内側から、そのループの次の反復処理に制御を移行する。\n\n
end /// 【コマンド】\nend\n\n【概要】\nマクロの実行そのものを終了する。\n\n【書式】\nend\n\n【解説】\nMACRO も終了する。\nexitコマンドとは厳密に異なる。\n\n参照\n\n"exit"\n\n
execcmnd /// 【コマンド】\nexeccmnd\n\n【概要】\nTTL コマンド を実行する。\n\n【書式】\nexeccmnd <statement>\n\n【解説】\n文字列 <statement> が表現する TTL コマンド を実行する。\n\n
exit /// 【コマンド】\nexit\n\n【概要】\nメインファイルへ戻る。\n\n【書式】\nexit\n\n【解説】\nインクルードファイルから抜け、メインファイルへ戻る。\nメインファイルで使用すると、マクロの実行そのものを終了する（endコマンドと等価）。\n\n参照\n\n"include"\n"end"\n\n
goto /// 【コマンド】\ngoto\n\n【概要】\nラベルへジャンプする。\n\n【書式】\ngoto <label>\n\n【解説】\n<label>行の次の行へジャンプする。\nなお、forやwhileなどのループを抜けるために、gotoは使えないため、代わりにbreakを使うこと。\n\n
include /// 【コマンド】\ninclude\n\n【概要】\nインクルードファイルに移る。\n\n【書式】\ninclude '<include file name>'\n\n【解説】\n引数に指定したマクロファイルを読み込み、マクロ実行を行う。実行終了後、includeコマンドの次の行から処理が再開される。\nなお、includeのネストは 9 までである。\n\n
mpause /// 【コマンド】\nmpause\n\n【概要】\n休止する。\n\n【書式】\nmpause <time>\n\n【解説】\nTTL の実行を <time> ミリ秒だけ休止する。\n\n
pause /// 【コマンド】\npause\n\n【概要】\n休止する。\n\n【書式】\npause <time>\n\n【解説】\nTTL の実行を <time> 秒だけ休止する。\n\n
return /// 【コマンド】\nreturn\n\n【概要】\nサブルーチンを抜け、メインルーチンへ戻る。\n\n【書式】\nreturn\n\n【解説】\n"call"\n\n
do /// 【コマンド】\ndo, loop\n\n【概要】\n繰り返す。\n\n【書式】\ndo [ { while | until } <expression> (option)]\n\n  ...\n\n  ...\n\nloop [ { while | until } <expression> (option)]\n\n【解説】\n'do' と 'loop' の間のコマンドを、条件式に従って繰り返す。\n条件式は、while の場合は<expression> が0以外である限り、until の場合は<expression>が0である限り繰り返す。\n'do' に条件式を指定した場合は、条件によっては一度もループが実行されない場合がある。'loop' に条件式を指定した場合は、最低1度はループが実行される。どちらにも条件を指定しなかった場合は、無限ループとなる。\n\n
loop /// 【コマンド】\ndo, loop\n\n【概要】\n繰り返す。\n\n【書式】\ndo [ { while | until } <expression> (option)]\n\n  ...\n\n  ...\n\nloop [ { while | until } <expression> (option)]\n\n【解説】\n'do' と 'loop' の間のコマンドを、条件式に従って繰り返す。\n条件式は、while の場合は<expression> が0以外である限り、until の場合は<expression>が0である限り繰り返す。\n'do' に条件式を指定した場合は、条件によっては一度もループが実行されない場合がある。'loop' に条件式を指定した場合は、最低1度はループが実行される。どちらにも条件を指定しなかった場合は、無限ループとなる。\n\n
for /// 【コマンド】\nfor, next\n\n【概要】\n繰り返す。\n\n【書式】\nfor <intvar> <first> <last>\n\n  ...\n\n  ...\n\nnext\n\n【解説】\n"for" と "next" の間のコマンドを、整数変数 <intvar> の値が <last> と等しくなるまで、繰りかえす。\n<intvar> の初期値は <first> 。もし <last> が <fast> より大きい場合、<intvar> は "next" 行に来るたびに 1 足される。もし <last> が <fast> より小さい場合、<intvar> は "next" 行にくるたびに 1 引かれる。\n\n
next /// 【コマンド】\nfor, next\n\n【概要】\n繰り返す。\n\n【書式】\nfor <intvar> <first> <last>\n\n  ...\n\n  ...\n\nnext\n\n【解説】\n"for" と "next" の間のコマンドを、整数変数 <intvar> の値が <last> と等しくなるまで、繰りかえす。\n<intvar> の初期値は <first> 。もし <last> が <fast> より大きい場合、<intvar> は "next" 行に来るたびに 1 足される。もし <last> が <fast> より小さい場合、<intvar> は "next" 行にくるたびに 1 引かれる。\n\n
if /// 【コマンド】\nif, then, elseif, else, endif\n\n【概要】\n条件分岐\n\n【書式1】\nif <expression> <statement>\n\n【解説1】\nもし <expression> が真(0以外)ならば、コマンド <statement> を実行する。\n\n【書式2】\nif <expression 1> then\n  ...\n  (<expression 1> が真(0以外)の場合に実行されるコマンド)\n  ...\n[elseif <expression 2> then]\n  ...\n  (<expression 1> が偽(0)で、<expression 2>が真の場合に実行されるコマンド)\n  ...\n[elseif <expression N> then]\n  ...\n  (<expression 1>, <expression 2>,.., <expression N-1> がすべて偽で、<expression N> が真の場合に実行されるコマンド)\n  ...\n[else]\n  ...\n  (上の条件すべてが偽の場合に実行されるコマンド)\n  ...\nendif\n\n【解説2】\n'then' は 'if' と 'elseif' 行の最後になければならない。\n'elseif' と 'else' はなくてもよい。\n'endif' は必要。
then /// 【コマンド】\nif, then, elseif, else, endif\n\n【概要】\n条件分岐\n\n【書式1】\nif <expression> <statement>\n\n【解説1】\nもし <expression> が真(0以外)ならば、コマンド <statement> を実行する。\n\n【書式2】\nif <expression 1> then\n  ...\n  (<expression 1> が真(0以外)の場合に実行されるコマンド)\n  ...\n[elseif <expression 2> then]\n  ...\n  (<expression 1> が偽(0)で、<expression 2>が真の場合に実行されるコマンド)\n  ...\n[elseif <expression N> then]\n  ...\n  (<expression 1>, <expression 2>,.., <expression N-1> がすべて偽で、<expression N> が真の場合に実行されるコマンド)\n  ...\n[else]\n  ...\n  (上の条件すべてが偽の場合に実行されるコマンド)\n  ...\nendif\n\n【解説2】\n'then' は 'if' と 'elseif' 行の最後になければならない。\n'elseif' と 'else' はなくてもよい。\n'endif' は必要。
elseif /// 【コマンド】\nif, then, elseif, else, endif\n\n【概要】\n条件分岐\n\n【書式1】\nif <expression> <statement>\n\n【解説1】\nもし <expression> が真(0以外)ならば、コマンド <statement> を実行する。\n\n【書式2】\nif <expression 1> then\n  ...\n  (<expression 1> が真(0以外)の場合に実行されるコマンド)\n  ...\n[elseif <expression 2> then]\n  ...\n  (<expression 1> が偽(0)で、<expression 2>が真の場合に実行されるコマンド)\n  ...\n[elseif <expression N> then]\n  ...\n  (<expression 1>, <expression 2>,.., <expression N-1> がすべて偽で、<expression N> が真の場合に実行されるコマンド)\n  ...\n[else]\n  ...\n  (上の条件すべてが偽の場合に実行されるコマンド)\n  ...\nendif\n\n【解説2】\n'then' は 'if' と 'elseif' 行の最後になければならない。\n'elseif' と 'else' はなくてもよい。\n'endif' は必要。
else /// 【コマンド】\nif, then, elseif, else, endif\n\n【概要】\n条件分岐\n\n【書式1】\nif <expression> <statement>\n\n【解説1】\nもし <expression> が真(0以外)ならば、コマンド <statement> を実行する。\n\n【書式2】\nif <expression 1> then\n  ...\n  (<expression 1> が真(0以外)の場合に実行されるコマンド)\n  ...\n[elseif <expression 2> then]\n  ...\n  (<expression 1> が偽(0)で、<expression 2>が真の場合に実行されるコマンド)\n  ...\n[elseif <expression N> then]\n  ...\n  (<expression 1>, <expression 2>,.., <expression N-1> がすべて偽で、<expression N> が真の場合に実行されるコマンド)\n  ...\n[else]\n  ...\n  (上の条件すべてが偽の場合に実行されるコマンド)\n  ...\nendif\n\n【解説2】\n'then' は 'if' と 'elseif' 行の最後になければならない。\n'elseif' と 'else' はなくてもよい。\n'endif' は必要。
endif /// 【コマンド】\nif, then, elseif, else, endif\n\n【概要】\n条件分岐\n\n【書式1】\nif <expression> <statement>\n\n【解説1】\nもし <expression> が真(0以外)ならば、コマンド <statement> を実行する。\n\n【書式2】\nif <expression 1> then\n  ...\n  (<expression 1> が真(0以外)の場合に実行されるコマンド)\n  ...\n[elseif <expression 2> then]\n  ...\n  (<expression 1> が偽(0)で、<expression 2>が真の場合に実行されるコマンド)\n  ...\n[elseif <expression N> then]\n  ...\n  (<expression 1>, <expression 2>,.., <expression N-1> がすべて偽で、<expression N> が真の場合に実行されるコマンド)\n  ...\n[else]\n  ...\n  (上の条件すべてが偽の場合に実行されるコマンド)\n  ...\nendif\n\n【解説2】\n'then' は 'if' と 'elseif' 行の最後になければならない。\n'elseif' と 'else' はなくてもよい。\n'endif' は必要。
until /// 【コマンド】\nuntil, enduntil\n\n【概要】\n繰り返す。\n\n【書式】\nuntil <expression>\n  ...\n  ...\nenduntil\n\n【解説】\n'until' と 'enduntil' の間のコマンドを、 <expression> が0である限り、繰り返す。\n\n
enduntil /// 【コマンド】\nuntil, enduntil\n\n【概要】\n繰り返す。\n\n【書式】\nuntil <expression>\n  ...\n  ...\nenduntil\n\n【解説】\n'until' と 'enduntil' の間のコマンドを、 <expression> が0である限り、繰り返す。\n\n
while /// 【コマンド】\nwhile, endwhile\n\n【概要】\n繰り返す。\n\n【書式】\nwhile <expression>\n  ...\n  ...\nendwhile\n\n【解説】\n'while' と 'endwhile' の間のコマンドを、 <expression> が0以外である限り、繰り返す。\n\n
endwhile /// 【コマンド】\nwhile, endwhile\n\n【概要】\n繰り返す。\n\n【書式】\nwhile <expression>\n  ...\n  ...\nendwhile\n\n【解説】\n'while' と 'endwhile' の間のコマンドを、 <expression> が0以外である限り、繰り返す。\n\n


●文字列操作コマンド
code2str /// 【コマンド】\ncode2str\n\n【概要】\nASCII コード値を文字列に変換する。\n\n【書式】\ncode2str <strvar> <ASCII code>\n\n【解説】\n整数値 <ASCII code> が 1〜255 の場合、ASCII コード <ASCII code> に対応する文字を文字列変数 <strvar> に格納する。\nこのコマンドは <ASCII code> で表される ASCII コード列を文字列に変換し、それを <strvar> に格納する。\n<ASCII code> の0でない最上位バイトがASCII コード列の1バイト目とみなされる。\n<ASCII code> が0の場合、 <strvar> には ""(空文字列) が格納される。文字列の最大長は 4。\n\n
expandenv /// 【コマンド】\nexpandenv\n\n【概要】\n環境変数文字列を展開する。\n\n【書式】\nexpandenv <strvar> [<strval>]\n\n【解説】\nパラメータ\n\n文字列変数 <strvar>\nこの引数で指定した文字列が展開される。\n第2引数(<strval>)を渡した場合は、展開結果が当該文字列変数に代入される。\n文字列 <strval> (オプション)\nこの引数を指定した場合、指定した文字列が展開され、文字列変数 <strvar>に代入される。\n解説\n\n1つ以上の環境変数文字列(%variableName%)を展開し、当該文字列をカレントユーザの定義された値に置き換える。\n\n
int2str /// 【コマンド】\nint2str\n\n【概要】\n整数値を文字列に変換する。\n\n【書式】\nint2str <strvar> <integer value>\n\n【解説】\n整数値 <integer value> を10進表現の文字列に変換して文字列型変数 <strvar> に代入する。\nsprintfシリーズの書式指定"%d"と等価である。\n\n
regexoption /// 【コマンド】\nregexoption\n\n【概要】\n正規表現の文法、文字エンコーディング、オプションを設定する。\n\n【書式】\nregexoption <option1> [<option2> ...]\n\n【解説】\nstrmatch, strreplace, waitregex で使用する正規表現の文法、文字エンコーディング、オプションを設定する。\n\nオプション option1 [option2 ...] には、以下の中から文法を1つ、エンコーディングを1つ、オプションを複数指定できる。\n各設定のデフォルト値は、文法: SYNTAX_RUBY, エンコーディング: ENCODING_ASCII, オプション: OPTION_NONE となる。\n\n
sprintf /// 【コマンド】\nsprintf\n\n【概要】\nフォーマットされた出力を返す。\n\n【書式】\nsprintf FORMAT [ARGUMENT ...]\n\n【解説】\nC言語の書式指定にしたがって、引数の数値や文字列をフォーマットして、文字列型変数 <inputstr> に代入する。\nsprintf2 とは違い、常に inputstr に結果を格納する。\n\nサポートされている書式指定\n型	c, d, i, o, u, x, X, e, E, f, g, G, a, A および s\nフラグ(オプション)	-, +, 0, # および 空白(' ')\n幅(オプション)	10進整数 または *\n精度(オプション)	ピリオド (.) に続けて、負でない10進整数 または *(オプション)\nTTL は浮動小数点型を持たないので、浮動小数点数の書式には、対応する小数を文字列変数あるいは文字列で引数に指定する。\n\nこのコマンドの結果、以下のうちの一つの値がシステム変数 result に格納される。\n\n値	状態\n0	成功した\n1	書式指定がない\n2	書式指定が不正\n3	引数が不正\n\n
sprintf2 /// 【コマンド】\nsprintf2\n\n【概要】\nフォーマットされた出力を返す。\n\n【書式】\nsprintf2 strvar FORMAT [ARGUMENT ...]\n\n【解説】\nC言語の書式指定にしたがって、引数の数値や文字列をフォーマットして、文字列型変数 <strvar> に代入する。\nsprintf とは違い、任意の変数に結果を格納できる。\n\nサポートされている書式指定\n型	c, d, i, o, u, x, X, e, E, f, g, G, a, A および s\nフラグ(オプション)	-, +, 0, # および 空白(' ')\n幅(オプション)	10進整数 または *\n精度(オプション)	ピリオド (.) に続けて、負でない10進整数 または *(オプション)\nTTL は浮動小数点型を持たないので、浮動小数点数の書式には、対応する小数を文字列変数あるいは文字列で引数に指定する。\n\nこのコマンドの結果、以下のうちの一つの値がシステム変数 result に格納される。\n\n値	状態\n0	成功した\n1	書式指定がない\n2	書式指定が不正\n3	引数が不正\n4	格納先変数が不正\n\n\n
str2code /// 【コマンド】\nstr2code\n\n【概要】\n文字列を ASCII コード値に変換する。\n\n【書式】\nstr2code <intvar> <string>\n\n【解説】\n文字列 <string> が1文字の場合、その文字の ASCII コードを整数変数 <intvar> に格納する。\n<string> の長さが2以上の場合、<string> をその ASCII コード列に変換し、それを <intvar> に格納する。 <intvar> は最大 4 個の ASCII コードを格納できる。\nもし <string> の長さが 4 文字より長い場合、ASCII コード列の最後の 4 バイトが <intvar> に格納される。\n\n
str2int /// 【コマンド】\nstr2int\n\n【概要】\n文字列を整数値に変換する。\n\n【書式】\nstr2int <intvar> <string>\n\n【解説】\n文字列 <string> を整数値に変換し、整数変数 <intvar> に代入する。\n文字列 <string> には10進、16進を指定することができる。以下に例を示す。\n\n10進 … 123, 0009\n16進 … 0x7b, $7b\n正常に変換できた場合は 1 、できなかった場合は 0 がシステム変数 result に代入される。\n\n
strcompare /// 【コマンド】\nstrcompare\n\n【概要】\n文字列を比較する。\n\n【書式】\nstrcompare <string1> <string2>\n\n【解説】\n2つの文字列 <string1>, <string2> を比較し、結果をシステム変数 result に代入する。\n文字列の文字コード表現を符号なし整数(最初の文字が最上位バイト)とみなし、2つの文字列に対応する整数値の大小関係を求め、それに応じて以下のようにresult の値が決定される。\n\n大小関係	resultの値\n<string1> < <string2>	-1\n<string1> = <string2>	0\n<string1> > <string2>	1\n\n
strconcat /// 【コマンド】\nstrconcat\n\n【概要】\n文字列を継ぎ足す。\n\n【書式】\nstrconcat <strvar> <string>\n\n【解説】\n文字列変数 <strvar> の文字列値の最後に 文字列 <string> を継ぎ足す。\n\n
strcopy /// 【コマンド】\nstrcopy\n\n【概要】\n文字列をコピーする。\n\n【書式】\nstrcopy <string> <pos> <len> <strvar>\n\n【解説】\n文字列 <string> の <pos> 文字目（1オリジン）から <len> 文字分を文字列変数 <strvar> にコピーする。\n\n
strinsert /// 【コマンド】\nstrinsert\n\n【概要】\n文字列を挿入する。\n\n【書式】\nstrinsert <strvar> <index> <string>\n\n【解説】\n文字列変数 <strvar> の <index> 位置（1オリジン）に、文字列 <string> を挿入する。\n\n
strjoin /// 【コマンド】\nstrjoin\n\n【概要】\n文字を連結する。\n\n【書式】\nstrjoin <strvar> <separator> [<count>]\n\n【解説】\ngroupmatchstr1〜groupmatchstr9 を区切り記号 <separator> で連結し、文字列変数 <strvar> に格納する。\n\n<separator> には区切り記号として扱う文字列を指定する。\n\n<count> には、連結する部分文字列の最大数（9以下）を指定する。\n<count> が省略された場合は 9 とみなされる。\n\n
strlen /// 【コマンド】\nstrlen\n\n【概要】\n文字列の長さを返す。\n\n【書式】\nstrlen <string>\n\n【解説】\n文字列 <string> の長さをシステム変数 result に格納する。\n長さはバイト単位でカウントされる。\n\n
strmatch /// 【コマンド】\nstrmatch\n\n【概要】\n正規表現によるパターンマッチングを行う。\n\n【書式】\nstrmatch <target string> <string with regular expression>\n\n【解説】\nOniguruma の正規表現 が使用できる。\n<target string>引数に指定された文字列を、正規表現 <string with regular expression> によるパターンに合致するかどうかを調べる。\nこのコマンドの実行結果はシステム変数 result , matchstr , groupmatchstr に格納される。変数 result の値の意味は以下のとおり。\n\n値	意味\n0	マッチしなかった\n1	マッチした位置（1オリジン）\n変数 matchstr には最初にマッチしたパターンが格納される。\n変数 groupmatchstr1〜groupmatchstr9 にはグループマッチしたパターンが格納される。\nなお、マッチしなかった場合には、これらの変数は strmatch 実行前の内容が保持される。\n\n日本語等のマルチバイト文字列を検索する場合、事前にregexoptionで適切なエンコーディングを設定しておく必要がある。\n\n
strremove /// 【コマンド】\nstrremove\n\n【概要】\n文字列を削除する。\n\n【書式】\nstrremove <strvar> <index> <len>\n\n【解説】\n文字列変数 <strvar> の <index> 位置（1オリジン）から <len> 文字分を削除し詰める。\n\n
strreplace /// 【コマンド】\nstrreplace\n\n【概要】\n文字列を置換する。\n\n【書式】\nstrreplace <strvar> <index> <regex> <newstr>\n\n【解説】\n文字列変数 <strvar> の <index> 位置（1オリジン）から、正規表現 <regex> を検索し、文字列 <newstr> に置き換える。\n<newstr> が ""(空文字列) の場合、<strvar> 中の <regex> は削除される。\n\n置換が成功すると、result 変数に"1"が入り、正規表現 <regex> でマッチした文字列は matchstr 変数に格納される。\n置換が失敗した場合は、result 変数が"0"になる。\n日本語等のマルチバイト文字列を検索する場合、事前にregexoptionで適切なエンコーディングを設定しておく必要がある。\n\nこのマクロコマンドを実行すると groupmatchstr システム変数の内容がクリアされる。\n\n
strscan /// 【コマンド】\nstrscan\n\n【概要】\n部分文字列の位置を返す\n\n【書式】\nstrscan <string> <substring>\n\n【解説】\n文字列 <string> の中に、 部分文字列 <substring> が含まれているかどうか調べる。\nもし、 <substring> が見つかった場合、その位置（1オリジン）がシステム変数 result に格納される。\n<substring> が複数含まれている場合、最初のものの位置が格納される。もし、 <substring> が見つからなかった場合、 result に0が格納される。\n\n
strspecial /// 【コマンド】\nstrspecial\n\n【概要】\n特殊文字を変換する。\n\n【書式】\nstrspecial <strvar> [<strval>]\n\n【解説】\nパラメータ\n\n文字列変数 <strvar>\nこの引数で指定した文字列が変換される。\n第2引数(<strval>)を渡した場合は、変換結果が当該文字列変数に代入される。\n文字列 <strval> (オプション)\nこの引数を指定した場合、指定した文字列が変換され、文字列変数 <strvar>に代入される。\n解説\n\n渡された文字列に含まれる以下の文字を特殊文字に変換する。\n\n入力	出力\n\\	"\"\n\ n	改行\n\t	タブ\n\n\n
strsplit /// 【コマンド】\nstrsplit\n\n【概要】\n文字列を分割する。\n\n【書式】\nstrsplit <strval> <separator> [<count>]\n\n【解説】\n文字列 <strval> から、区切り記号 <separator> で区切られた部分文字列を取り出して、groupmatchstr1〜groupmatchstr9に返す。\n\n<separator> には区切り記号として扱う文字を1文字だけ指定する。\n\n<count> には、取得する部分文字列の最大数（9以下）を指定する。 \n文字列中の部分文字列の数が <count> 未満であるとき、部分文字列が代入されなかったgroupmatchstrには、""(空文字列) が代入される。\n文字列中の部分文字列の数が <count> を超えるとき、最後のgroupmatchstrには残りの文字列がすべて代入される。\n\n<count> が省略された場合には、部分文字列の最大数は 9 とみなされる。\n文字列中の部分文字列の数が 9 を超えるとき、<count> を指定した場合とは違い 9 番目の部分文字列のみが代入される。\n\n実際に分割された個数をシステム変数 result に格納する。\n<count> が省略され、文字列中の部分文字列の数が 9 を超えるときは、システム変数 result に 10 を格納する。\n\n
strtrim /// 【コマンド】\nstrtrim\n\n【概要】\n前後の文字を削除する。\n\n【書式】\nstrtrim <strvar> <trimchars>\n\n【解説】\n文字列変数 <strvar>の先頭と末尾から、<trimchars> で指定された文字をすべて削除する。\n\n
tolower /// 【コマンド】\ntolower\n\n【概要】\n文字列をすべて小文字に変換する。\n\n【書式】\ntolower <strvar> <string>\n\n【解説】\n<string> に含まれるアルファベットを全て小文字にし、 <strvar> に代入する。\n\n
toupper /// 【コマンド】\ntoupper\n\n【概要】\n文字列をすべて大文字に変換する。\n\n【書式】\ntoupper <strvar> <string>\n\n【解説】\n<string> に含まれるアルファベットを全て大文字にし、 <strvar> に代入する。\n\n

●ファイル操作コマンド
basename /// 【コマンド】\nbasename\n\n【概要】\nパス名からファイル名を得る。\n\n【書式】\nbasename <strvar> <path>\n\n【解説】\nパス名 <path> からファイル名部分を <strvar> に格納する。\nパス名は文字列として処理しており、実在している必要はない。\n\n
dirname /// 【コマンド】\ndirname\n\n【概要】\nパス名からディレクトリ名を得る。\n\n【書式】\ndirname <strvar> <path>\n\n【解説】\nパス名 <path> のディレクトリ名部分を <strvar> に格納する。\nパス名は文字列として処理しており、実在している必要はない。\n\n
fileclose /// 【コマンド】\nfileclose\n\n【概要】\nファイルハンドルを閉じる。\n\n【書式】\nfileclose <file handle>\n\n【解説】\nファイルハンドル <file handle> で指定されるファイルをクローズする。\nこのコマンド実行後、<file handle> は無効となる。\n\n
fileconcat /// 【コマンド】\nfileconcat\n\n【概要】\nファイルの内容を別のファイルに追加する。\n\n【書式】\nfileconcat <file1> <file2>\n\n【解説】\nファイル <file2> の内容をファイル <file1> の最後に追加する。\n<file1> と <file2> は違うファイルでなければならない。\n<file2> の追加が成功した場合、システム変数 result に 0 が格納される。それ以外の場合, result に 0 以外が格納される。\n\n
filecopy /// 【コマンド】\nfilecopy\n\n【概要】\nファイルをコピーする。\n\n【書式】\nfilecopy <file1> <file2>\n\n【解説】\nファイル <file1> をコピーし、ファイル <file2> を作成する。\n<file2> がすでに存在する場合は上書きされる。<file1> と <file2> は違う名前でなければならない。\nファイルの削除が成功した場合、システム変数 result に 0 が格納される。それ以外の場合, result に 0 以外が格納される。\n\n
filecreate /// 【コマンド】\nfilecreate\n\n【概要】\nファイルを作成する。\n\n【書式】\nfilecreate <file handle> <filename>\n\n【解説】\nファイル <filename> を新しく作成しオープンする。\nファイルポインタはファイルの先頭にセットされる。すでに同じ名前のファイルが存在する場合、ファイルサイズは0にされる。\nもしファイルが正しく作成され、オープンされた場合、ファイルハンドルが整数変数 <file handle> に格納される。それ以外の場合、<file handle> に-1が格納される。\nファイルの作成が成功した場合、システム変数 result に 0 が格納される。それ以外の場合, result に 0 以外が格納される。\n\nなお、ファイル作成後、ファイルハンドルはオープンされたままとなる。\n\n
filedelete /// 【コマンド】\nfiledelete\n\n【概要】\nファイルを削除する。\n\n【書式】\nfiledelete <filename>\n\n【解説】\nファイル <filename> を削除する。\nファイルの削除が成功した場合、システム変数 result に 0 が格納される。それ以外の場合, result に 0 以外が格納される。\n\n
filelock /// 【コマンド】\nfilelock\n\n【概要】\n開いているファイルをロックする。\n\n【書式】\nfilelock <file handle> [<timeout>]\n\n【解説】\nすでに開いているファイルハンドル <file handle> を指定すると、ファイル全体をロックする。 ロック中、他のプロセスからの当該ファイルへのアクセスはエラーとなる。\n引数 <timeout> の意味については下記のとおり。\n\n<timeout>	説明\n0	ファイルがすでにロックされていたら、即座にエラーを返す。\n省略	ファイルがすでにロックされていたら、解除されるまで無限に待つ。\nValue	ファイルがすでにロックされていたら、解除されるまで最大 Value 秒待つ。タイムアウトしたらエラーを返す。\nロックに成功すると result 変数が 0 に、失敗すると 1 となる。\n\n
filemarkptr /// 【コマンド】\nfilemarkptr\n\n【概要】\nファイルポインタを保存する。\n\n【書式】\nfilemarkptr <file handle>\n\n【解説】\n<file handle> で指定されるオープンされているファイルの現在のファイルポインタを保存する。\n保存されたファイルポインタは "fileseekback" によって呼び戻すことができる。\n\n
fileopen /// 【コマンド】\nfileopen\n\n【概要】\nファイルを開く。\n\n【書式】\nfileopen <file handle> <filename> <append flag> [<readonly flag>]\n\n【解説】\n整数変数 <file handle>\nもしファイルが正しくオープンされた場合、ファイルハンドルが格納される。\nそれ以外の場合、<file handle> に-1が格納される。\n文字列 <filename>\n開くファイル名を指定する。\nファイルが存在しない場合は、新たに作成されてからオープンされる。\n整数 <append flag>\n0を指定すると、ファイルポインタの位置はファイルの始めにセットされる。\n0以外を指定すると、ファイルポインタはファイルの最後にセットされる。\n整数 <readonly flag> (オプション デフォルト=0) (バージョン 4.85 以降)\n0を指定すると、読み書きモードでファイルを開く。\n0以外を指定すると、読み取り専用モードでファイルを開く。\n解説\n\nファイルはバイナリモードでオープンされる。\n\n
filereadln /// 【コマンド】\nfilereadln\n\n【概要】\nファイルから一行読む。\n\n【書式】\nfilereadln <file handle> <strvar>\n\n【解説】\nファイルハンドル <file handle> で指定されるファイルから一行読む。\n読み込まれた行は、文字列変数 <strvar> に格納される。\nファイルポインタは次の行の始めへ移動する。もし、行を読んでいる間にファイルポインタがファイルの\n最後に達した場合、システム変数 result に 1 が格納される。それ以外の場合、result に 0 が格納される。\n改行のみの場合は、文字列変数は空となり、result には 0 が格納される。\n\n
fileread /// 【コマンド】\nfileread\n\n【概要】\nファイルを読む。\n\n【書式】\nfileread <file handle> <read byte> <strvar>\n\n【解説】\n<file handle> により指定されたファイルから特定したバイト数のデータを読み出す。\nデータは文字列変数 <strvar> へ記憶され、ファイルポインタは読み込んだバイト数分進められる。\nデータを読み込み終わる前にファイルポインタがファイルの終わりまで行った場合は、システム変数 "result" に 1 が格納される。 それ以外は、"result" に 0 が格納される。\n変数 <read byte> のとる値の範囲は 1 から 511 でなければならない。\n\n
filerename /// 【コマンド】\nfilerename\n\n【概要】\nファイル名を変更する。\n\n【書式】\nfilerename <file1> <file2>\n\n【解説】\nファイル <file1> を <file2> という名前に変更する。\n<file1> と <file2> は違う名前でなければならない。\nファイル名の変更が成功した場合、システム変数 result に 0 が格納される。それ以外の場合, result に 0 以外が格納される。\n\n
filesearch /// 【コマンド】\nfilesearch\n\n【概要】\nファイルまたはフォルダがあるか確かめる。\n\n【書式】\nfilesearch <filename>\n\n【解説】\nファイルまたはフォルダ <filename> が存在するかどうか調べる。\n存在する場合は、システム変数 result に1が返る。存在しない場合は、result に0が返る。\n\n
fileseek /// 【コマンド】\nfileseek\n\n【概要】\nファイルポインタを移動する。\n\n【書式】\nfileseek <file handle> <offset> <origin>\n\n【解説】\nファイルハンドル <file handle> で指定されるファイルのファイルポインタを移動する。\n移動後のファイルポインタは下記のようになる。\n\n<origin>	0	ファイルの最初から <offset> バイト\n<origin>	1	現在の位置から <offset> バイト\n<origin>	2	ファイルの最後から <offset> バイト\n\n\n
fileseekback /// 【コマンド】\nfileseekback\n\n【概要】\n"filemarkptr" コマンドで保存した位置にファイルポインタを移動する。\n\n【書式】\nfileseekback <file handle>\n\n【解説】\nファイルハンドル <file handle> で指定されるファイルのファイルポインタを移動する。\n移動後のファイルポインタは下記のようになる。\n\n
filestat /// 【コマンド】\nfilestat\n\n【概要】\nファイルの統計情報を取得する。\n\n【書式】\nfilestat <filename> <size> [<mtime>] [<drive>] \n\n【解説】\nファイル <filename> の統計情報を取得する。\nファイルサイズを <size> 、最終変更時間を <mtime> 、ドライブ番号を <drive> に格納する。\n取得に失敗した場合は、result 変数に -1 が格納される。\n\n
filestrseek /// 【コマンド】\nfilestrseek\n\n【概要】\n文字列をファイルの先頭から末尾に向かって検索する。\n\n【書式】\nfilestrseek <file handle> <string>\n\n【解説】\nファイルハンドル <file handle> で指定されるファイルから、文字列 <string> を検索する。\n検索は現在のファイルポインタの位置から開始する。検索はファイルの終わりの方に向かって行われる。逆方向の検索には "filestrseek2" コマンドを使用する。\n<string> が見つかった場合、ファイルポインタは <string> の次の文字の位置になり、システム変数 result に 1 が格納される。\n<string> が見つからなかった場合、ファイルポインタは移動せず、システム変数 result に 0 が格納される。\n\n
filestrseek2 /// 【コマンド】\nfilestrseek2\n\n【概要】\n文字列をファイルの末尾から先頭へ向かって検索する。\n\n【書式】\nfilestrseek2 <file handle> <string>\n\n【解説】\nファイルハンドル <file handle> で指定されるファイルから、文字列 <string> を検索する。\n検索は現在のファイルポインタの位置から開始する。検索はファイルの先頭の方に向かって行われる。逆方向の検索には "filestrseek" コマンドを使用する。\n<string> が見つかった場合、ファイルポインタは <string> の直前の文字の位置になり、システム変数 result に 1 が格納される。ただし、ファイルの1バイト目だった場合は、ファイルポインタはゼロオフセットとなる。\n<string> が見つからなかった場合、ファイルポインタは移動せず、システム変数 result に 0 が格納される。\nこのコマンドを実行する前にすでにファイルポインタが 0 の場合、result に 0 が格納される。\n\n
filetruncate /// 【コマンド】\nfiletruncate\n\n【概要】\nファイルのサイズを変更する。\n\n【書式】\nfiletruncate <filename> <size>\n\n【解説】\nファイル <filename> をサイズ <size> バイトの大きさに変更する。\n指定したサイズが、既存の大きさを超えた場合、ヌル文字('\0')が追加される。\n\nサイズ変更に成功した場合は、result 変数に 0 が格納される。失敗した場合は -1 が格納される。\n\n
fileunlock /// 【コマンド】\nfileunlock\n\n【概要】\n開いているファイルのロックを解除する。\n\n【書式】\nfileunlock <file handle>\n\n【解説】\nすでに開いているファイルハンドル <file handle> を指定すると、ファイル全体のロックを解除する。\n\nロックの解除に成功すると result 変数が 0 に、失敗すると 1 となる。\n\n
filewrite /// 【コマンド】\nfilewrite\n\n【概要】\nファイルにデータを書き込む。\n\n【書式】\nfilewrite <file handle> <data>\n\n【解説】\nファイルハンドル <file handle> で指定されるファイルへ、<data> を書き込む。\n\n<data> が文字列型の場合、文字列を書き込む。\n<data> が整数型の場合は、その値の下位バイト(0-255)を ASCII コードとみなし、その文字を書き込む。\n\n
filewriteln /// 【コマンド】\nfilewriteln\n\n【概要】\nファイルにデータを改行付きで書き込む。\n\n【書式】\nfilewriteln <file handle> <data>\n\n【解説】\nファイルハンドル <file handle> で指定されるファイルへ、<data> と改行文字 (CR+LF) を書き込む。\n\n<data> が文字列型の場合、文字列を書き込む。\n<data> が整数型の場合は、その値の下位バイト(0-255)を ASCII コードとみなし、その文字を書き込む。\n\n
findfirst /// 【コマンド】\nfindfirst\n\n【概要】\n文字列に合致する最初のファイルを探す。\n\n【書式】\nfindfirst <dir handle> <file name> <strvar>\n\n【解説】\nfindfirst コマンドはファイル名 <file name> に合致する最初のファイルを探す。\nファイルが見つかった場合、ディレクトリハンドルが <dir handle> に、最初のファイル名が <strvar> に格納され、システム変数 <result> に 1 が格納される。\nfindfirst コマンドが最初のファイルを見つけた場合、ディレクトリハンドルを指定して findnext コマンドを使用し、 <file name> に合致する次のファイルを探すことができる。\nディレクトリハンドルは findclose コマンドによって解放されなければならない。\n\n
findnext /// 【コマンド】\nfindnext\n\n【概要】\n文字列に合致する次のファイルを探す。\n\n【書式】\nfindnext <dir handle> <strvar>\n\n【解説】\nfindnext コマンドは findfirst コマンドで指定されたファイル名に合致する次のファイルを探す。\n整数値 <dir handle> は findfirst コマンドで得られたディレクトリハンドルでなければならない。\nもし次のファイルが見つかった場合、<strvar> にファイル名が、"result" に 1 が格納される。\nそれ以外の場合は、<strvar>と "result" にそれぞれ "" と 0 が格納される。\n\n
findclose /// 【コマンド】\nfindclose\n\n【概要】\nディレクトリハンドルを解放する。\n\n【書式】\nfindclose <dir handle>\n\n【解説】\nfindclose コマンドは findfirst コマンドによって得られたディレクトリハンドル <dir handle> を解放する。\nこのコマンドはファイル検索処理が不要になった時点で、即座に実行されなければならない。\n\n
foldercreate /// 【コマンド】\nfoldercreate\n\n【概要】\nフォルダを作成する。\n\n【書式】\nfoldercreate <foldername>\n\n【解説】\nフォルダ <foldername> を新しく作成する。\nフォルダの作成が成功した場合、システム変数 result に 0 が格納される。それ以外の場合, result に 0 以外が格納される。\n\n
folderdelete /// 【コマンド】\nfolderdelete\n\n【概要】\nフォルダを削除する。\n\n【書式】\nfolderdelete <foldername>\n\n【解説】\nフォルダ <foldername> を削除する。\nフォルダの削除が成功した場合、システム変数 result に 0 が格納される。それ以外の場合, result に 0 以外が格納される。\nただし、フォルダが空でない場合には削除できない。\n\n
foldersearch /// 【コマンド】\nfoldersearch\n\n【概要】\nフォルダがあるか確かめる。\n\n【書式】\nfoldersearch <foldername>\n\n【解説】\nフォルダ <foldername> が存在するかどうか調べる。\n存在する場合は、システム変数 result に1が返る。存在しない場合は、result に0が返る。\n\n注意\n\nfoldersearch コマンドは、<foldername> がファイルとして存在する場合には0を返す。このため、フォルダ作成前の存在チェックには使用できない。\n\n
getdir /// 【コマンド】\ngetdir\n\n【概要】\nMACRO の現在のディレクトリを得る。\n\n【書式】\ngetdir <strvar>\n\n【解説】\n(Tera Term ではなく) MACRO の現在のディレクトリを文字列変数 <strvar> に格納する。\nルートディレクトリの場合、文字列の末尾には円記号 (\) が付く。ルート以外のディレクトリの場合、文字列はディレクトリ名で終わり、末尾に円記号は付かない。\n\n
getfileattr /// 【コマンド】\ngetfileattr\n\n【概要】\nファイルまたはディレクトリの属性を得る。\n\n【書式】\ngetfileattr <filename>\n\n【解説】\n文字列 <filename>\nファイル名またはディレクトリ名\n返り値\n\nシステム変数 <result>\n属性の取得に失敗すると -1 が格納される。\n取得に成功すると、属性値が格納される。属性値は以下の数値の組み合わせとなる。\n値	意味\n$1	読み取り専用\n$2	隠しファイルまたは隠しディレクトリ\n$4	オペレーティングシステムの一部、またはオペレーティングシステム専用\n$10	ディレクトリ\n$20	アーカイブ\n$80	特に属性はない\n$100	一時ファイル\n$200	スパースファイル\n$400	再解析ポイントが関連付けられているか、シンボリックリンク\n$800	圧縮されている\n$1000	オフラインの記憶装置へ物理的に移動された(Windows 2000 以降)\n$2000	「インデックスサービス」の対象になっていない(Windows 2000 以降)\n$4000	暗号化されている\n\n\n
makepath /// 【コマンド】\nmakepath\n\n【概要】\nフルパス名を作成する。\n\n【書式】\nmakepath <strvar> <dir> <name>\n\n【解説】\nディレクトリ名 <dir> とファイル名 <name> からフルパス名を作成し、文字列変数 <strvar> に格納する。 もし必要なら <dir> と <name> の間に "\" を挿入する。\n\n
setdir /// 【コマンド】\nsetdir\n\n【概要】\nMACRO の現在のディレクトリを変更する。\n\n【書式】\nsetdir <dir>\n\n【解説】\nMACRO の現在のディレクトリを <dir> に変更する。\n\n注意: changedir コマンドは Tera Term の現在のディレクトリを変更する。\n通信コマンド(kmtsend 等)で指定されるファイル名は Tera Term の現在のディレクトリを基準にする。\nその他のコマンド(fileopen 等)で指定されるファイル名はMACRO の現在のディレクトリを基準にする。\n\n
setfileattr /// 【コマンド】\nsetfileattr\n\n【概要】\nファイルまたはディレクトリの属性を変更する。\n\n【書式】\nsetfileattr <filename> <attributes>\n\n【解説】\n文字列 <filename>\nファイル名またはディレクトリ名\n整数 <attributes>\n設定する属性値を指定する。属性値は以下の数値の組み合わせとなる。\n値	意味\n$1	読み取り専用\n$2	隠しファイルまたは隠しディレクトリ\n$4	オペレーティングシステムの一部、またはオペレーティングシステム専用\n$20	アーカイブ\n$80	特に属性はない,単独で指定したときのみ有効\n$100	一時ファイル\n$1000	オフラインの記憶装置へ物理的に移動された(Windows 2000 以降)\n$2000	「インデックスサービス」の対象になっていない(Windows 2000 以降)\n返り値\n\nシステム変数 <result>\n属性の変更に失敗すると0が格納される。\n成功すると1が格納される。\n\n

●パスワードコマンド
delpassword /// 【コマンド】\ndelpassword\n\n【概要】\nパスワードを削除する。\n\n【書式】\ndelpassword <filename> <password name>\n\n【解説】\nパスワードファイル <filename> の中にある <password name> で指定されたパスワードを削除する。\nもし <password name> が空の文字列ならば、ワードファイルの中にあるすべてのパスワードが削除される。\n\n
getpassword /// 【コマンド】\ngetpassword\n\n【概要】\nパスワードを読み出す。\n\n【書式】\ngetpassword <filename> <password name> <strvar>\n\n【解説】\nパスワードファイル <filename> から <password name> で指定されるパスワードを読みだす。\nそのパスワードは暗号化されているので、それを解読してから文字列変数 <strvar> に保存する。\n\nもし指定されたファイルが存在しなければ、新しくファイルを作成する。 もし指定されたパスワードがファイルの中になければ、パスワードダイアログボックスが現れ、入力されたパスワードは文字列変数 <strvar> に保存される。\n同時に、その新しいパスワードは暗号化されパスワード識別子 <password name> と共にファイルに書き込まれる。\n\n一つのパスワードファイルに複数のパスワードを保存することができる。\n各パスワードはパスワード識別子によって識別される。\n\n(バージョン 4.71 以降)\nパスワードファイルへの書き込みに失敗した場合、システム変数 result に 0 が格納される。それ以外の場合、result に 1 が格納される。\n\n
ispassword /// 【コマンド】\nispassword\n\n【概要】\nパスワードが設定されているかを判別する。\n\n【書式】\nispassword <filename> <password name>n\n【解説】\nパスワードファイル <filename> から <password name> で指定されるパスワードが存在するかを調べる。\n\nパスワードファイルに <password name> に対応するパスワードが設定されているならば、システム変数 result に 1 が格納される。それ以外の場合、result に 0 が格納される。\n\n
passwordbox /// 【コマンド】\npasswordbox\n\n【概要】\nパスワードを入力するためのダイアログボックスを開く。\n\n【書式】\npasswordbox <message> <title> [<special>]\n\n【解説】\n文字列 <message>\nダイアログボックスに表示されるメッセージ。\n\n文字列 <title>\nダイアログボックスのタイトル。\n\n整数値 <special> (オプション デフォルト=0)\n0 でない場合は、<message> に含まれる以下の文字列は特殊文字として扱われます。\n\n入力	出力\n\\	"\"\n\ n	改行\n\t	タブ\n\nこのオプションの使用は推奨されません。strspecial マクロコマンドを使用して文字列を変換することで同等の結果を得られます。\n\n返り値\nシステム変数 <inputstr>\n入力された文字列が代入される。\n\n\n解説\n\n入力されるパスワードはそのまま表示されず、かわりに、"****" のように表示される。\n\n
setpassword /// 【コマンド】\nsetpassword\n\n【概要】\nパスワードを追加もしくは更新する。\n\n【書式】\nsetpassword <filename> <password name> <strvar>\n\n【解説】\nパスワードファイル <filename> から <password name> で指定されるパスワードを <strvar> に更新する。\n文字列変数 <strvar> のパスワードは暗号化され、ファイルに保存される。\n\nもし指定されたファイルが存在しなければ、新しくファイルを作成する。\n\n一つのパスワードファイルに複数のパスワードを保存することができる。\n各パスワードはパスワード識別子によって識別される。\n\nパスワードファイルへの書き込みに失敗した場合、システム変数 result に 0 が格納される。それ以外の場合、result に 1 が格納される。\n\n

●その他コマンド
beep /// 【コマンド】\nbeep\n\n【概要】\nビープ音を鳴らす。\n\n【書式】\nbeep [<sound type>]\n\n【解説】\nWAVE 形式のサウンドを再生する。\n引数の意味は以下のとおり。省略時は「SystemDefault；一般の警告音」となる。\n\n値	サウンド\n0	コンピュータのスピーカから発生する標準的なビープ音\n1	SystemAsterisk；メッセージ（情報）\n2	SystemExclamation；メッセージ（警告）\n3	SystemHand；システムエラー\n4	SystemQuestion；メッセージ（問い合わせ）\n5	SystemDefault；一般の警告音\n\n
bringupbox /// 【コマンド】\nbringupbox\n\n【概要】\nstatusbox コマンドによって開かれたステータスダイアログボックスを最前面に表示する。\n\n【書式】\nbringupbox\n\n【解説】\nなし。\n返り値\n\nなし。\n\n
closesbox /// 【コマンド】\nclosesbox\n\n【概要】\nstatusbox コマンドによって開かれたステータスダイアログボックスを閉じる。\n\n【書式】\nclosesbox\n\n【解説】\n"statusbox" を参照。\n\n
clipb2var /// 【コマンド】\nclipb2var\n\n【概要】\nクリップボードのテキストデータをコピーする。\n\n【書式】\nclipb2var <strvar> [<offset>]\n\n【解説】\nクリップボードのテキストデータを <strvar> へ代入する。\n文字列変数の最大長の制限を受けるため、クリップボードのテキストデータが長すぎた場合は512バイト目以降が切り捨てられる。\n\n<offset>を指定すると、offset*511+1文字目以降の内容が代入される。\n<offset>に0以外を指定するためには、事前に<offset>無し、または<offset>に0を指定してclipb2varを実行する必要がある。\n<offset>に0以外を指定した時に得られるクリップボードの内容は現在のものではなく、最後に<offset>無し、または<offset>に0を指定してclipb2varを実行した時点でのクリップボードの内容となる。\n\nこのコマンドの実行結果はシステム変数 result に格納される。変数 result の値の意味は以下のとおり。\n\n値	意味\n0	クリップボードを開けなかった。またはテキストデータではなかった。またはoffsetの値が適切ではなかった。\n1	<strvar> への代入に成功した。\n2	<strvar> への代入は行われたが、入りきらなかった部分は切り捨てられた。offsetの値を増やして再度clipb2varコマンドを実行する事で、切り捨てられた部分にアクセスできる。\n3	クリップボードの内容を記憶しておくためのメモリの確保に失敗した。この場合でも先頭から最大511バイトは変数に代入されるが、offsetを増やして再度clipb2varコマンドを実行しても切り捨てられた部分にはアクセスできない。\n\n
exec /// 【コマンド】\nexec\n\n【概要】\nアプリケーションを起動する。\n\n【書式】\nexec <command line> [<show> [<wait> [<current directory>]]]\n\n【解説】\nコマンドライン文字列 <command line> に従い、アプリケーションを起動する。\n\n<show> パラメータには以下の文字列を指定することができる。\nhide\nminimize\nmaximize\nshow ;default parameters when no show command specified. \n<wait> パラメータに 1 を指定すると、起動したアプリケーションが終了するまで待つ。アプリケーションの終了コードが result システム変数に格納される。(バージョン 4.63以降)\n<current directory> パラメータは、カレントディレクトリを指定することができる。(バージョン 4.78以降)\n\n
dirnamebox /// 【コマンド】\ndirnamebox\n\n【概要】\nディレクトリ名を選択するダイアログボックスを開く。\n\n【書式】\ndirnamebox <title> [<initialdir>]\n\n【解説】\n文字列 <title>\nダイアログボックスのタイトル\n文字列 <initialdir> (オプション デフォルト="")\nダイアログボックスの初期ディレクトリを指定する。\n空文字列や無効なパスを指定すると、デスクトップが初期ディレクトリになる。\n返り値\n\nシステム変数 <result>\nユーザがディレクトリ名を選択してOKボタンを押すと1が格納され、inputstrにフォルダ名が格納される。\nユーザがダイアログをキャンセルしたり閉じたりすると0が格納される。\nシステム変数 <inputstr>\n選択されたディレクトリ名\n\n
filenamebox /// 【コマンド】\nfilenamebox\n\n【概要】\nファイル名を選択するダイアログボックスを開く。\n\n【書式】\nfilenamebox <title> [<dialogtype> [<initialdir>]]\n\n【解説】\n文字列 <title>\n	ダイアログボックスのタイトル\n\n整数 <dialogtype> (オプション デフォルト=0) (バージョン 4.65 以降)\n	ダイアログボックスの種類を指定する。\n	0を指定すると［ファイルを開く］ダイアログボックスを開く。\n	0以外の値を指定すると［ファイル名を付けて保存］ダイアログボックスを開く。\n\n文字列 <initialdir> (オプション デフォルト="") (バージョン 4.85 以降)\n	ダイアログボックスの初期ディレクトリを指定する。\n	空文字列や無効なパスを指定すると、Windows の仕様(OPENFILENAME構造体のlpstrInitialDirの仕様)により初期ディレクトリが決定される。\n\n\n返り値\n\nシステム変数 <result> (バージョン 4.65 以降)\n	ユーザがファイル名を入力してOKボタンを押すと0以外の値が格納され、inputstrにファイル名が格納される。\n	ユーザがダイアログをキャンセルしたり閉じたりすると0が格納される。\n\nシステム変数 <inputstr>\n	入力されたファイル名\n\n
getdate /// 【コマンド】\ngetdate\n\n【概要】\n現在の日付を得る。\n\n【書式】\ngetdate <strvar> [<format> [<timezone>]]\n\n【解説】\n現在の日付を文字列変数 <strvar> に <format> に従った形式で格納する。書式は strftime と同じ物が使える。\nformatが省略された場合、格納される形式は"YYYY-MM-DD"となる。(<format> に %Y-%m-%d を指定したのと同じ)\nformatが指定されたgetdateは、同じformatが指定されたgettimeと動作が等しくなる。\n<timezone> にタイムゾーンを表す文字列を指定すると、タイムゾーンを加味した日付計算が行われる。 <timezone> を指定しない場合はローカルタイムとなる。\n\nformatが指定された場合、このコマンドの実行結果はシステム変数 result に格納される。 formatが指定されなかった場合は、変数 result の値は変更されない。 変数 result の値の意味は以下のとおり。\n\n値	意味\n0	正常に値が <strvar> に格納された。\n1	生成された文字列の長さが上限(511文字)を超えた等の理由で、<strvar> への値の格納が正常に行われなかった。\n2	<format> の指定が不正である。\n\n
getenv /// 【コマンド】\ngetenv\n\n【概要】\n環境変数を得る。\n\n【書式】\ngetenv <envname> <strvar>\n\n【解説】\n環境変数 <envname> の値を文字列変数 <strvar> に格納する。\n\n
getipv4addr /// 【コマンド】\ngetipv4addr\n\n【概要】\n自端末のIPv4アドレスを取得する。\n\n【書式】\ngetipv4addr <string array> <num>\n\n【解説】\n文字列配列 <string array>\nIPアドレスを格納する文字型配列。\n整数型変数 <num>\nIPアドレスの個数を格納する整数型変数。IPアドレスが存在しない場合、0が格納される。\n返り値\n\nシステム変数 <result>\nIPアドレスの取得に成功した場合、1が格納される。\nIPアドレスの個数が<string array>の要素数より大きい場合、0が格納される。\nIPアドレスの取得に失敗した場合、-1が格納される。\n\n
getipv6addr /// 【コマンド】\ngetipv6addr\n\n【概要】\n自端末のIPv6アドレスを取得する。\n\n【書式】\ngetipv6addr <string array> <num>\n\n【解説】\n配列 <string array>\nIPアドレスを格納する文字型配列。\n整数型変数 <num>\nIPアドレスの個数を格納する整数型変数。IPアドレスが存在しない場合、0が格納される。\n返り値\n\nシステム変数 <result>\nIPアドレスの取得に成功した場合、1が格納される。\nIPアドレスの個数が<string array>の要素数より大きい場合、0が格納される。\nIPアドレスの取得に失敗した場合、-1が格納される。Windows 2000 以前では常に失敗する。\n\n
getspecialfolder /// 【コマンド】\ngetspecialfolder\n\n【概要】\n特殊フォルダのパスを取得する。\n\n【書式】\ngetspecialfolder <strvar> <foldertype>\n\n【解説】\nWindows の特殊フォルダを取得して <strvar> に格納します。\n\nパラメータ\n\n文字列変数 <strvar>\n	取得された文字列が格納される。\n\n文字列 <foldertype>\n	この引数で指定した種類の特殊フォルダが文字列変数 <strvar>に代入される。\n\nAllUsersDesktop…All Usersの「デスクトップ」フォルダ\nAllUsersStartMenu…All Usersの「スタートメニュー」フォルダ\nAllUsersPrograms…All Usersのスタートメニューの「プログラム」フォルダ\nAllUsersStartup…All Usersのスタートメニューの「スタートアップ」フォルダ\nDesktop…「デスクトップ」仮想フォルダ\nFavorites…「お気に入り」フォルダ\nFonts…「フォント」仮想フォルダ\nMyDocuments…「マイ ドキュメント」仮想フォルダ\nNetHood…「マイネットワーク」仮想フォルダ\nPrintHood…「プリンタ」仮想フォルダ\nPrograms…スタートメニューの「プログラム」フォルダ\nRecent…「最近使ったファイル」フォルダ\nSendTo…コンテキストメニューの「送る」フォルダ\nStartMenu…「スタートメニュー」フォルダ\nStartup…スタートメニューの「スタートアップ」フォルダ\nTemplates…「テンプレート」フォルダ\n\ncf. CSIDL(MSDN library)\n\n\n返り値\n\nシステム変数 <result>\n	取得に失敗すると0が格納される。\n	成功すると1が格納される。\n\n
gettime /// 【コマンド】\ngettime\n\n【概要】\n現在の時刻を得る。\n\n【書式】\ngettime <strvar> [<format> [<timezone>]]\n\n【解説】\n現在の時刻を文字列変数 <strvar> に <format> に従った形式で格納する。書式は strftime と同じ物が使える。\nformatが省略された場合、格納される形式は"HH:MM:SS"となる。(<format> に %H:%M:%S を指定したのと同じ)\nformatが指定されたgettimeは、同じformatが指定されたgetdateと動作が等しくなる。\n<timezone> にタイムゾーンを表す文字列を指定すると、タイムゾーンを加味した日付計算が行われる。 <timezone> を指定しない場合はローカルタイムとなる。\n\nformatが指定された場合、このコマンドの実行結果はシステム変数 result に格納される。 formatが指定されなかった場合は、変数 result の値は変更されない。 変数 result の値の意味は以下のとおり。\n\n値	意味\n0	正常に値が <strvar> に格納された。\n1	生成された文字列の長さが上限(511文字)を超えた等の理由で、<strvar> への値の格納が正常に行われなかった。\n2	<format> の指定が不正である。\n\n
getttdir /// 【コマンド】\ngetttdir\n\n【概要】\nttpmacro.exe があるディレクトリを得る。\n\n【書式】\ngetttdir <strvar>\n\n【解説】\nttpmacro.exe があるディレクトリを文字列変数 <strvar> に格納する。\nディレクトリの取得に成功した場合は、システム変数 result に1が返る。失敗した場合は、result に0が返る。\n\n
getver /// 【コマンド】\ngetver\n\n【概要】\nTera Termのバージョンを取得する。\n\n【書式】\ngetver <strvar> [<version>]\n\n【解説】\nTera Termのバージョンを <strvar> に格納する。\n\n<version> が指定された場合、<version> と実行中の Tera Term のバージョンを比較し、結果をシステム変数 result に格納する。<version> が指定されなかった場合は、変数 result の値は変更されない。変数 result の値の意味は以下のとおり。\n\n値	意味\n-2	<version> の指定が不正である。\n-1	Tera Termのバージョンが <version> より古い。\n0	Tera Termのバージョンが <version> と同じ。\n1	Tera Termのバージョンが <version> より新しい。\n\n
ifdefined /// 【コマンド】\nifdefined\n\n【概要】\n型を調べる。\n\n【書式】\nifdefined <var>\n\n【解説】\n<var> の型を表す値をシステム変数 result に格納する。変数 result の値の意味は以下のとおり。\n\n値	意味\n0	定義されていない\n1	整数型\n3	文字列型\n4	ラベル\n5	整数配列型\n6	文字列配列型\n\n
inputbox /// 【コマンド】\ninputbox\n\n【概要】\n文字列を入力するためのダイアログボックスを開く。\n\n【書式】\ninputbox <message> <title> [<default> [<special>]]\n\n【解説】\n文字列 <message>\n	ダイアログボックスに表示されるメッセージ。\n\n文字列 <title>\n	ダイアログボックスのタイトル。\n\n文字列 <default> (オプション デフォルト=""(空文字列))\n	エディットコントロールのデフォルト文字列です。\n\n整数値 <special> (オプション デフォルト=0)\n	0 でない場合は、<message> に含まれる以下の文字列は特殊文字として扱われます。\n	<special> の値は <default> には影響を与えません。\n	入力	出力\n	\\	"\"\n	\ n	改行\n	\t	タブ\n	このオプションの使用は推奨されません。strspecial マクロコマンドを使用して文字列を変換することで同等の結果を得られます。\n\n\n返り値\n\nシステム変数 <inputstr>\n	入力された文字列が代入される。\n\n
intdim /// 【コマンド】\nintdim\n\n【概要】\n整数配列型の変数を宣言する。\n\n【書式】\nintdim <array> <size>\n\n【解説】\n<size>個の要素を持つ整数配列型の変数<array>を宣言する。<size>は 1 〜 65536 の範囲の値を持つことができ、配列の添字は0オリジンである。\n配列内の各要素の初期値は0。\n\n
listbox /// 【コマンド】\nlistbox\n\n【概要】\nリストボックスを開き、ユーザーに項目を選択させる。\n\n【書式】\nlistbox <message> <title> <string array> [<selected>]\n\n【解説】\n文字列 <message>\nリストボックスに表示されるメッセージ。\n文字列 <title>\nリストボックスのタイトル。\n文字列型配列 <string array>\nリストボックスの選択項目。\n整数値 <selected> (バージョン 4.89 以降)\n初期選択項目(0オリジンインデックス)。省略可能。\n返り値\n\nシステム変数 <result>\n項目が選択された場合、0 - (N-1)のいずれかの値が格納される。\nキャンセルされた場合、-1が格納される。\n解説\n\nlistbox マクロコマンドは <string array> の配列要素をすべて選択項目として表示します。\n以下のように、表示しようとする選択項目数より大きい要素数で <string array> を定義すると、最後に空文字列が表示されます。\n\nstrdim msg 4\nmsg[0] = 'バナナ' \nmsg[1] = 'りんご' \nmsg[2] = 'みかん'\nlistbox '好きな食べ物を選んでください' 'あなたへの問い' msg\n\n; 選択肢が4つ表示される\nバナナ\nりんご\nみかん\n[空文字列]\n\n\n(バージョン 4.89 以降)\n<selected> を指定する事で、初期状態で選択されている項目を指定する事ができます。\n省略した場合は 0 (先頭)が指定されたものとして扱われます。\n\n
messagebox /// 【コマンド】\nmessagebox\n\n【概要】\nダイアログボックスを開き、ユーザーにメッセージを知らせる。\n\n【書式】\nmessagebox <message> <title> [<special>]\n\n【解説】\n文字列 <message>\n	ダイアログボックスに表示されるメッセージ。\n\n文字列 <title>\n	ダイアログボックスのタイトル。\n\n整数値 <special> (オプション デフォルト=0)\n	0 でない場合は、<message> に含まれる以下の文字列は特殊文字として扱われます。\n	入力	出力\n	\\	"\"\n	\ n	改行\n	\t	タブ\n\nこのオプションの使用は推奨されません。strspecial マクロコマンドを使用して文字列を変換することで同等の結果を得られます。\n\n
random /// 【コマンド】\nrandom\n\n【概要】\n乱数を生成する。\n\n【書式】\nrandom <integer variable> <max number>\n\n【解説】\n0から<max number>までの整数の一様乱数を生成し、整数変数<integer variable>へ代入する。<max number>は0を超える数値でなければならない。\n\n
rotateleft /// 【コマンド】\nrotateleft\n\n【概要】\n左にローテート(循環シフト)する。\n\n【書式】\nrotateleft <intvar> <intval> <count>\n\n【解説】\n整数値 <intval> を左に <count> 桁ローテート(循環シフト)した値を整数型変数 <intvar> にコピーする。\n\n
rotateright /// 【コマンド】\nrotateright\n\n【概要】\n右にローテート(循環シフト)する。\n\n【書式】\nrotateright <intvar> <intval> <count>\n\n【解説】\n整数値 <intval> を右に <count> 桁ローテート(循環シフト)した値を整数型変数 <intvar> にコピーする。\n\n
setdate /// 【コマンド】\nsetdate\n\n【概要】\nシステムの日付を変更する。\n\n【書式】\nsetdate <date>\n\n【解説】\nシステムの日付を変更 <date> に変更する。<date> の形式は "YYYY-MM-DD"。\n\n
setdlgpos /// 【コマンド】\nsetdlgpos\n\n【概要】\nダイアログボックスの位置を設定する。\n\n【書式】\nsetdlgpos <x> <y>\n\n【解説】\n"inputbox", "messagebox", "passwordbox", "statusbox" , "listbox" コマンドで表示されるダイアログボックスの初期位置を変更する。\nまた、ステータスダイアログボックスが表示されている場合、setdlgpos コマンドはそのダイアログボックスを移動させる。\n<x> と <y> は画面の座標 (x,y) を表わす。原点 (0,0) は画面の左上の隅の位置。\n\n
setenv /// 【コマンド】\nsetenv\n\n【概要】\n環境変数を変更する。\n\n【書式】\nsetenv <envname> <strval>\n\n【解説】\n環境変数 <envname> に <strval> をセットする。\nセットされた値はマクロ内でのみ有効で、システムには影響しない。\nすでに値がセットされている環境変数を <envname> に指定した場合、値は上書きされる。\n\n
setexitcode /// 【コマンド】\nsetexitcode\n\n【概要】\nMACRO の終了コードを設定する。\n\n【書式】\nsetexitcode <exit code>\n\n【解説】\nWindows 98/Me の場合\n\nMACRO がバッチファイルからコマンドライン "start /w ttpmacro <ttl filename>" (オプション /w が必要)によって実行された場合、終了コードを DOS コマンド "if errorlevel n" で調べることができる。\n\nWindows NT/2000/XP の場合\n\nMACRO がバッチファイルからコマンドライン "ttpmacro <ttl filename>" によって実行された場合、終了コードを DOS コマンド"if errorlevel n" で調べることができる。\n\n
settime /// 【コマンド】\nsettime\n\n【概要】\nシステムの時刻を変更する。\n\n【書式】\nsettime <time>\n\n【解説】\nシステムの時刻を <time> に変更する。<time> の形式は "HH:MM:SS"。\n\n
show /// 【コマンド】\nshow\n\n【概要】\nMACRO ダイアログの表示状態を変更する。\n\n【書式】\nshow <show flag>\n\n【解説】\n<show flag> が0の場合、MACRO を最小化する。\n<show flag> が0より大きい場合、MACRO を元の大きさに戻して最前面に表示する。\n<show flag> が0より小さい場合、MACRO を隠す。\n\n
statusbox /// 【コマンド】\nstatusbox\n\n【概要】\nステータスダイアログボックスを表示する。\n\n【書式】\nstatusbox <message> <title> [<special>]\n\n【解説】\n文字列 <message>\n	ダイアログボックスに表示されるメッセージ。\n\n文字列 <title>\n	ダイアログボックスのタイトル。\n\n整数値 <special> (オプション デフォルト=0)\n	0 でない場合は、<message> に含まれる以下の文字列は特殊文字として扱われます。\n	入力	出力\n	\\	"\"\n	\ n	改行\n	\t	タブ\n\n\nこのオプションの使用は推奨されません。strspecial マクロコマンドを使用して文字列を変換することで同等の結果を得られます。\n\n\n解説\n\nステータスダイアログボックスが表示されていない場合、それを表示します。\nダイアログボックスのメッセージを <message> に、タイトルを <title> に変えます。\n\n"setdlgpos" コマンドはステータスダイアログボックスの位置を変えます。\n"closesbox" コマンドはステータスダイアログボックスを閉じます。EnterキーやESCキーでは閉じることはできません。\n\n
strdim /// 【コマンド】\nstrdim\n\n【概要】\n文字列配列型の変数を宣言する。\n\n【書式】\nstrdim <array> <size>\n\n【解説】\n<size>個の要素を持つ整数配列型の変数<array>を宣言する。<size>は 1 〜 65536 の範囲の値を持つことができ、配列の添字は0オリジンである。\n配列内の各要素の初期値は空文字列。\n\n
uptime /// 【コマンド】\nuptime\n\n【概要】\nOSの稼働時間を取得する。\n\n【書式】\nuptime <intvar>\n\n【解説】\nWindows OSの稼働時間（ミリ秒）を <intvar> に格納する。\n\n※稼働時間が49日を経過すると、0に戻る。\n\n
var2clipb /// 【コマンド】\nvar2clipb\n\n【概要】\nテキストデータをクリップボードにコピーする。\n\n【書式】\nvar2clipb <string>\n\n【解説】\n<string>をクリップボードにコピーする。\nこのコマンドの実行結果はシステム変数 result に格納される。変数 result の値の意味は以下のとおり。\n\n値	意味\n0	クリップボードを開けなかった。\n1	クリップボードへのコピーに成功した。\n\n\n
yesnobox /// 【コマンド】\nyesnobox\n\n【概要】\nダイアログボックスを開き、ユーザーに「はい」/「いいえ」を選択させる。\n\n【書式】\nyesnobox <message> <title> [<special>]\n\n【解説】\n文字列 <message>\n	ダイアログボックスに表示されるメッセージ。\n\n文字列 <title>\n	ダイアログボックスのタイトル。\n\n整数値 <special> (オプション デフォルト=0)\n	0 でない場合は、<message> に含まれる以下の文字列は特殊文字として扱われます。\n	入力	出力\n	\\	"\"\n	\ n	改行\n	\t	タブ\n\n\nこのオプションの使用は推奨されません。strspecial マクロコマンドを使用して文字列を変換することで同等の結果を得られます。\n\n\n返り値\n\nシステム変数 <result>\n	「はい」ボタンが押された場合、1が格納される。\n	「いいえ」ボタンが押された場合、0が格納される。\n\n
checksum8 /// 【コマンド】\nchecksum8, checksum8file\n\n【概要】\n8bit checksumを計算する。\n\n【書式】\nchecksum8 <intvar> <string>\nchecksum8file <intvar> <filename>\n\n【解説】\n引数の文字列およびファイルから加算サム(8bit)を計算する。 \n\n計算結果は intvar 変数に数値として格納される。\nchecksum8file でファイルが開けなかった場合は、result 変数に -1 が格納される。\n\n
checksum8file /// 【コマンド】\nchecksum8, checksum8file\n\n【概要】\n8bit checksumを計算する。\n\n【書式】\nchecksum8 <intvar> <string>\nchecksum8file <intvar> <filename>\n\n【解説】\n引数の文字列およびファイルから加算サム(8bit)を計算する。 \n\n計算結果は intvar 変数に数値として格納される。\nchecksum8file でファイルが開けなかった場合は、result 変数に -1 が格納される。\n\n
checksum16 /// 【コマンド】\nchecksum16, checksum16file\n\n【概要】\n16bit checksumを計算する。\n\n【書式】\nchecksum16 <intvar> <string>\nchecksum16file <intvar> <filename>\n\n【解説】\n引数の文字列およびファイルから加算サム(16bit)を計算する。 \n\n計算結果は intvar 変数に数値として格納される。\nchecksum16file でファイルが開けなかった場合は、result 変数に -1 が格納される。\n\n
checksum16file /// 【コマンド】\nchecksum16, checksum16file\n\n【概要】\n16bit checksumを計算する。\n\n【書式】\nchecksum16 <intvar> <string>\nchecksum16file <intvar> <filename>\n\n【解説】\n引数の文字列およびファイルから加算サム(16bit)を計算する。 \n\n計算結果は intvar 変数に数値として格納される。\nchecksum16file でファイルが開けなかった場合は、result 変数に -1 が格納される。\n\n
checksum32 /// 【コマンド】\nchecksum32, checksum32file\n\n【概要】\n32bit checksumを計算する。\n\n【書式】\nchecksum32 <intvar> <string>\nchecksum32file <intvar> <filename>\n\n【解説】\n引数の文字列およびファイルから加算サム(32bit)を計算する。 \n\n計算結果は intvar 変数に数値として格納される。\nchecksum32file でファイルが開けなかった場合は、result 変数に -1 が格納される。\n\n
checksum32file /// 【コマンド】\nchecksum32, checksum32file\n\n【概要】\n32bit checksumを計算する。\n\n【書式】\nchecksum32 <intvar> <string>\nchecksum32file <intvar> <filename>\n\n【解説】\n引数の文字列およびファイルから加算サム(32bit)を計算する。 \n\n計算結果は intvar 変数に数値として格納される。\nchecksum32file でファイルが開けなかった場合は、result 変数に -1 が格納される。\n\n
crc16 /// 【コマンド】\ncrc16, crc16file\n\n【概要】\nCRC-16-IBMを計算する。\n\n【書式】\ncrc16 <intvar> <string>\ncrc16file <intvar> <filename>\n\n【解説】\n引数の文字列およびファイルからCRC(Cyclic Redundancy Checking)を計算する。多項式（右回り）は以下のとおり。 \n\n0xA001 (x16+x15+x2+x0) \n\n計算結果は intvar 変数に数値として格納される。\ncrc16file でファイルが開けなかった場合は、result 変数に -1 が格納される。\n\n
crc16file /// 【コマンド】\ncrc16, crc16file\n\n【概要】\nCRC-16-IBMを計算する。\n\n【書式】\ncrc16 <intvar> <string>\ncrc16file <intvar> <filename>\n\n【解説】\n引数の文字列およびファイルからCRC(Cyclic Redundancy Checking)を計算する。多項式（右回り）は以下のとおり。 \n\n0xA001 (x16+x15+x2+x0) \n\n計算結果は intvar 変数に数値として格納される。\ncrc16file でファイルが開けなかった場合は、result 変数に -1 が格納される。\n\n
crc32 /// 【コマンド】\ncrc32, crc32file\n\n【概要】\nCRC-32を計算する。\n\n【書式】\ncrc32 <intvar> <string>\ncrc32file <intvar> <filename>\n\n【解説】\n引数の文字列およびファイルからCRC(Cyclic Redundancy Checking)を計算する。多項式（右回り）は以下のとおり。 \n\n100000100110000010001110110110111 (x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x1+x0) \n\n計算結果は intvar 変数に数値として格納される。\ncrc32file でファイルが開けなかった場合は、result 変数に -1 が格納される。\n\n
crc32file /// 【コマンド】\ncrc32, crc32file\n\n【概要】\nCRC-32を計算する。\n\n【書式】\ncrc32 <intvar> <string>\ncrc32file <intvar> <filename>\n\n【解説】\n引数の文字列およびファイルからCRC(Cyclic Redundancy Checking)を計算する。多項式（右回り）は以下のとおり。 \n\n100000100110000010001110110110111 (x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x1+x0) \n\n計算結果は intvar 変数に数値として格納される。\ncrc32file でファイルが開けなかった場合は、result 変数に -1 が格納される。\n\n

